## 模拟退火

### 算法简介

模拟退火（Simulated Annealing, SA）是一种基于概率的优化算法，灵感来源于金属退火过程。它通过模拟高温下分子运动逐渐冷却的过程，用于在复杂搜索空间中寻找全局最优解。算法通过接受次优解以跳出局部最优，适用于解决组合优化问题，如旅行商问题（TSP）、函数优化等。

### 算法流程

1. **初始化**：选择初始解 $x_0$，设置初始温度 $T_0$，冷却系数 $\alpha$，终止温度 $T_{\text{end}}$。
1. **生成新解**：通过扰动当前解 $x_0$ 生成新解 $x'$。**随机扰动**或向**更优秀**的方向移动。
1. **接受准则**：计算新解与当前解的目标函数差 $\Delta E = f(x') - f(x_0)$。
若 $\Delta E \leq 0$，接受新解 $x'$。
若 $\Delta E > 0$，则以概率 $P = e^{- \frac {\Delta}{T}}$ 接受新解。


1. **更新温度**：按冷却策略（通常 $T = T \cdot \alpha $）降低温度。
1. **终止条件**：若温度低于 $T_{\text{end}}$ 或达到最大迭代次数，停止并返回最优解。

### c++伪代码
```cpp
// 计算函数值
double f(double x) {
    double ans = ...
    ...
    return ans;
}

void sa() {
    double t = 1000;        // 初始温度
    double a = 0.995;       // 降温系数
    double eps = 1e-15;     // 最低温度

    double x0 = 0;     // 初始解

    while (t > eps) {
        // 新解，随机扰动
        // 或向更优秀的方向移动
        double x1 = x0 + (2 * rand() - RAND_MAX) * t;
        // 若新解不在定义域可能要重新生成
        while (x1 > maxv || x1 < minv) x1 = x0 + (2 * rand() - RAND_MAX) * t;

        double delta = f(x1) - f(x0);   // 目标函数差
        if (delta < 0) {                // 当前值更小，并且是求最小值问题，则接受新解
            // 接受新解、更新答案
        }
        else if (exp(-delta / t) * RAND_MAX > rand()) {  // 否则以一定概率接受新解
            // 接受新解
        }
    }

    t *= a; // 降温
}

```

### 多次运行

模拟退火算法可能取得局部最优解甚至错误解，在时间允许的情况下可以多次运行，提高找到全局最优解的概率。
- **控制运行次数示例 1**
```cpp
int main() {
    double time_limit = 1900;   // 时间限制，毫秒数
    auto start = chrono::high_resolution_clock::now();
    srand(time(0));
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y >> p[i].c;
    }

    auto end = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
    double time_used = duration.count() / 1000.0;;  // 毫秒数

    while (1) {
        start = chrono::high_resolution_clock::now();
        sa();
        end = chrono::high_resolution_clock::now();
        duration = chrono::duration_cast<chrono::microseconds>(end - start);
        time_ms = duration.count() / 1000.0; // 毫秒数
        time_used += time_ms;

        if (time_ms * 2 > time_limit - time_used) break; // 剩余时间不多就退出，乘 2 可能过于保守
    }

    cout << fixed << setprecision(10) << ans << '\n';

    return 0;
}
```

- **控制运行次数示例 2**
```cpp
int main() {
    double time_limit = 1900;   // 时间限制，毫秒数
    double time_used = 0;
    auto start = chrono::high_resolution_clock::now();
    auto set_time = [&] () {start = chrono::high_resolution_clock::now();};
    auto get_time = [&] () {
        auto duration = chrono::duration_cast<chrono::microseconds>(chrono::high_resolution_clock::now() - start);
        return duration.count() / 1000.0;
    };
    
    set_time();
    srand(time(0));
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y >> p[i].c;
    }
    time_used = get_time(); // 输入所需的时间

    while (1) {
        set_time();
        sa();
        time_used += get_time();    // get_time() 单次模拟退火的时间
        if (get_time() > time_limit - time_used) break; // 剩余时间不多就退出
    }

    cout << fixed << setprecision(10) << ans << '\n';

    return 0;
}
```