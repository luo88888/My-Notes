## 傅里叶变换

### 1 快速傅里叶变换（FFT、IDFT，多项式系数表示法 <-> 点值表示法）

```cpp
// Times of testing: 3
const double PI = acos(-1.0);

// 二进制位翻转，需保证 n 是 2 的幂
void bit_reverse(std::vector<std::complex<double> > &a, int len) {
    if (len <= 0) return;
    if (len & (len - 1)) throw std::runtime_error("n必须是2的幂");
    std::vector<int> rev(len);    // rev[i]: i 翻转后的值
    rev[0] = 0;
    for (int i = 0; i < len; ++i) {
        rev[i] = rev[i >> 1] >> 1;
        if (i & 1) rev[i] |= (len >> 1);
    }
    for (int i = 0; i < len; ++i) {
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    }
}

// 原地 FFT，len 必须是 2 的幂
void fft(std::vector<std::complex<double> > &a, int len, int inv) {
    bit_reverse(a, len);
    // 合并过程，从长度为 1 合并为长度为 2，一直合并到长度为 len
    for (int h = 2; h <= len; h <<= 1) {
        std::complex<double> wn(std::cos(2 * PI / h), sin(inv * 2 * PI / h));
        // 合并，共 len / h 次
        for (int j = 0; j < len; j += h) {
            // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
            std::complex<double> w(1, 0);
            for (int k = j; k < j + h / 2; ++k) {
                std::complex<double> u = a[k], t = w * a[k + h / 2];
                a[k] = u + t;
                a[k + h / 2] = u - t;
                w *= wn;
            }
        }
    }

    // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
    if (inv == -1) {
        for (int i = 0; i < len; ++i) {
            a[i] /= len;
        }
    }
}
```