## 计算几何

### 1 二维平面上点的定义
```c++
const double eps = 1e-6
struct Point {
    double x, y;
    Ponit(double x1 = 0.0, double y1 = 0.0) : x(x1), y(y1) {}
    Point operator+(const Point &p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point &p) const {
        return Point(x - p.x, y - p.y);
    }
    bool operator==(const Point &p) const {
        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;
    }
    // 内积
    double dot(const Point &p) const {
        return x * p.x + y * p.y;
    }
    // 外积
    double cross(const Point &p) const {
        return x * p.y - y * p.x;
    }
}

```

### 2 二维平面上直线的定义
```c++
struct Line {
    double a, b, c; // ax + by + c = 0
    Line(double a1 = 0.0, double b1 = 0.0, double c1 = 0.0) : a(a1), b(b1), c(c1) {}
    Line(const Point &p1, const Point &p2) {
        a = p2.y - p1.y;
        b = p1.x - p2.x;
        c = p2.x * p1.y - p1.x * p2.y;
    }
    // 判断点是否在直线上
    bool onLine(const Point &p) const {
        return fabs(a * p.x + b * p.y + c) < eps;
    }
};
```

### 3 二维平面上线段的定义
```c++
struct Segment {
    Point p1, p2;
    Segment(const Point &p1, const Point &p2) : p1(p1), p2(p2) {}
    // 判断点是否在线段上
    bool onSegment(const Point &p) const {
        return onLine(p) && (p.x >= min(p1.x, p2.x) && p.x <= max(p1.x, p2.x)) &&
               (p.y >= min(p1.y, p2.y) && p.y <= max(p1.y, p2.y));
    }
    // 判断两线段是否相交
    bool intersect(const Segment &s) const {
        double d1 = (s.p2 - s.p1).cross(p1 - s.p1);
        double d2 = (s.p2 - s.p1).cross(p2 - s.p1);
        double d3 = (p2 - p1).cross(s.p1 - p1);
        double d4 = (p2 - p1).cross(s.p2 - p1);
        return (d1 * d2 < 0 && d3 * d4 < 0) || (d1 == 0 && onSegment(s.p1)) ||
               (d2 == 0 && onSegment(s.p2)) || (d3 == 0 && s.onSegment(p1)) ||
               (d4 == 0 && s.onSegment(p2));
    }
};
```

### 凸包

```c++
using ld = long double;
const ld eps = 1e-12;

struct Point {
    ld x, y;

    Point operator - (const Point &p) {
        return {x - p.x, y - p.y};
    }

    bool operator < (const Point &p) const {
        if (fabs(x - p.x) > eps) return x < p.x;
        if (fabs(y - p.y) > eps) return y < p.y;
        return false;
    }
};

ld cross(Point p1, Point p2) {
    return p1.x * p2.y - p1.y * p2.x;
}

// 计算凸包
vector<Point> convex_hull(vector<Point> p) {
    sort(p.begin(), p.end());    // x 递增，x 相等 y 递增
    // p.erase(unique(p.begin(), p.end()), p.end());    // 去重，需重载 ==
    if (p.size() <= 2) return p;    // !!! 实际可能需要去重

    vector<Point> res;
    int cnt = 0;

    // 计算下凸包
    for (int i = 0; i < p.size(); i++) {
        // < -eps 包含共线点和重复点（严格右转）
        // < eps 不包含共线点和重复点（不左转）
        // 确保与计算下凸包时一致
        while (cnt >= 2 && cross(res[cnt - 1] - res[cnt - 2], p[i] - res[cnt - 1]) < eps) {
            res.pop_back();
            cnt--;
        }
        res.push_back(p[i]);
        cnt++;
    }

    // 计算上凸包
    int lower_cnt = cnt;
    for (int i = (int)p.size() - 2; i >= 0; i--) {
        while (cnt > lower_cnt && cross(res[cnt - 1] - res[cnt - 2], p[i] - res[cnt - 1]) < eps) {
            res.pop_back();
            cnt--;
        }
        res.push_back(p[i]);
        cnt++;
    }

    res.pop_back(); // 第一个点算了两次

    return res;
}

```