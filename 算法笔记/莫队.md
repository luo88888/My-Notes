## 莫队算法

### 1 基础莫队算法

#### 1.1 算法简介


#### 1.2 示例

- **查询指定区间中不同的数的个数**
> 问题描述：
> 现有数列 $A_1, A_2, ..., A_N$，$Q$ 个询问 $(L_i, R_i)$，问 $A_{L_i}, A_{L_i+1}, ..., A_{R_i}$ 中不同的数的数量。
> 数据范围：
> $1 <= N <= 3 \times 10^4, 1 <= Q <= 10^5，1 <= A_i <= 10^6, 1 <= L_i <= R_i <= N$

- **示例代码**
```c++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
struct Query {
    int l, r, block, id;
    bool operator < (const Query &b) {
        return block == b.block ? r < b.r : block < b.block;
    }
};
int num;    // 区间中不同的数的数量
int a[30005];                   // 3e4
int cnt[1000005], ans[200005];  // 1e6, 2e5
Query q[200005];                // 2e5
void add(int x) {               // 加入 a[x]
    cnt[a[x]]++;
    if (cnt[a[x]] == 1) num++;
}
void remove(int x) {            // 移除 a[x]
    cnt[a[x]]--;
    if (cnt[a[x]] == 0) num--;
}
int main() {
    int n, m, l, r, block_size;
    cin >> n;
    block_size = sqrt(n);
    for (int i = 1; i <= n; i++) cin >> a[i];
    cin >> m;
    for (int i = 1; i <= m; i++) {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
        q[i].block = (q[i].l - 1) / block_size + 1; //
    }
    sort(q + 1, q + m + 1);
    l = r = q[1].l;         // 初始化
    num = cnt[a[l]] = 1;    // 初始化
    for (int i = 1; i <= m; i++) {
        while (l < q[i].l) remove(l++);
        while (l > q[i].l) add(--l);
        while (r < q[i].r) add(++r);
        while (r > q[i].r) remove(r--);
        ans[q[i].id] = num;
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
    return 0;
}
```

### 2 带修改的莫队算法

#### 2.1 算法简介

#### 2.2 示例
