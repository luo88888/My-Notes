### 网络流
给定一个有向图，每条边有容量，求从源点到汇点的最大流。

#### 网络流常用算法：
- **Edmonds-Karp算法（EK）**：使用BFS寻找增广路径，时间复杂度为$O(VE^2)$。
- **Dinic算法**：基于分层图，使用DFS寻找阻塞流，时间复杂度为$O(V^2E)$，单位容量网络或二分图为$O(E \sqrt{V})$。
- **Push-Relabel算法**：基于预流思想，时间复杂度为$O(V^2E)$，优化版本可达$O(V^2 \sqrt{E})$。
- **费用流算法**：在最大流基础上考虑边费用，常用SPFA（$O(F \cdot E)$）或堆优化Dijkstra（$O(F \cdot (E + V \log V))$）实现，其中F是最大流量。

EK（Edmonds-Karp）+SPFA或Dijkstra是最常见的实现方式。


#### Edmonds-Karp（EK）实现（$O(VE^2)$）
```cpp
// Times of testing: 1
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const int INF = 1e9;

struct Edge {
    int to;
    ll cap;
    int rev; // 反向边在节点 to 的邻接表中的索引
};

void add_edge(vector<vector<Edge>>& g, int u, int v, ll cap) {
    g[u].push_back({v, cap, (int)g[v].size()});
    g[v].push_back({u, 0, (int)g[u].size() - 1}); // 反向边初始容量为0
}

ll bfs(vector<vector<Edge>>& g, vector<int> &pre, vector<int> &idx, int s, int t) {
    vector<int> flow(g.size() + 1, INF); // 节点到源点的最大流量
    queue<int> q;
    q.push(s);
    pre[s] = -1; // 前驱节点
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (u == t) break; // 找到汇点，结束搜索
        for (int i = 0; i < g[u].size(); ++i) {
            Edge &e = g[u][i];
            if (pre[e.to] == -1 && e.cap > 0) { // 未访问且有剩余容量
                pre[e.to] = u;
                idx[e.to] = i; // 记录边的索引
                flow[e.to] = min(flow[u], (int)e.cap);
                q.push(e.to);
            }
        }
    }
    if (pre[t] == -1) return -1; // 无增广路径
    return flow[t];
}

ll max_flow(int n, vector<vector<Edge>>& g, int s, int t) {
    ll totalFlow = 0;
    vector<int> pre(n + 1, -1); // 前驱节点数组
    vector<int> idx(n + 1, -1); // 
    
    while (true) {
        fill(pre.begin(), pre.end(), -1);
        ll flow = bfs(g, pre, idx, s, t);
        if (flow == -1) break; // 无增广路径，结束
        totalFlow += flow;
        
        // 沿增广路径更新容量
        for (int u = t; u != s; u = pre[u]) {
            Edge &e = g[pre[u]][idx[u]];
            e.cap -= flow;
            g[u][e.rev].cap += flow; // 更新反向边
        }
    }
    return totalFlow;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, s, t;
    cin >> n >> m >> s >> t;
    vector<vector<Edge>> g(n + 1);
    
    for (int i = 0; i < m; ++i) {
        int u, v;
        ll w;
        cin >> u >> v >> w;
        add_edge(g, u, v, w);
    }
    
    cout << max_flow(n, g, s, t) << "\n";
    
    return 0;
}
```

#### Dinic实现（$O(V^2E)$）
```cpp
// Times of testing: 1
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const int INF = 1e9;

struct Edge {
    int to;
    ll cap;
    int rev; // 反向边在节点 to 的邻接表中的索引
};

void add_edge(vector<vector<Edge>>& g, int u, int v, ll cap) {
    g[u].push_back({v, cap, (int)g[v].size()});
    g[v].push_back({u, 0, (int)g[u].size() - 1}); // 反向边初始容量为0
}

// 建立分层网络
bool bfs(vector<vector<Edge>>& g, vector<int>& level, int s, int t) {
    fill(level.begin(), level.end(), -1);
    level[s] = 0;
    queue<int> q;
    q.push(s);
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (const Edge& e : g[u]) {
            if (level[e.to] == -1 && e.cap > 0) { // 未访问且有剩余容量
                level[e.to] = level[u] + 1;
                q.push(e.to);
            }
        }
    }
    return level[t] != -1; // 是否能到达汇点
}

// 在分层网络中寻找增广路径
ll dfs(vector<vector<Edge>>& g, vector<int>& ptr, vector<int>& level, int u, int t, ll flow) {
    if (u == t) return flow;
    if (flow == 0) return 0;
    
    for (int& i = ptr[u]; i < g[u].size(); ++i) {
        Edge& e = g[u][i];
        if (level[e.to] == level[u] + 1 && e.cap > 0) {
            ll pushed = dfs(g, ptr, level, e.to, t, min(flow, e.cap));
            if (pushed > 0) {
                e.cap -= pushed;
                g[e.to][e.rev].cap += pushed;
                return pushed;
            }
        }
    }
    return 0;
}

ll dinic(int n, vector<vector<Edge>>& g, int s, int t) {
    ll totalFlow = 0;
    vector<int> level(n + 1); // 节点层级
    vector<int> ptr(n + 1);   // 当前节点的边指针
    
    while (bfs(g, level, s, t)) { // 只要存在增广路径
        fill(ptr.begin(), ptr.end(), 0); // 重置指针
        while (ll flow = dfs(g, ptr, level, s, t, INF)) { // 找阻塞流
            totalFlow += flow;
        }
    }
    return totalFlow;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, s, t;
    cin >> n >> m >> s >> t;
    vector<vector<Edge>> g(n + 1);
    
    for (int i = 0; i < m; ++i) {
        int u, v;
        ll w;
        cin >> u >> v >> w;
        add_edge(g, u, v, w);
    }
    
    cout << dinic(n, g, s, t) << "\n";
    
    return 0;
}
```


### 最小费用最大流
在最大流的基础上，每条边有费用，求在满足最大流的前提下，费用最小的流。
最小费用最大流的一个解决方法：Ford-Fulkerson + SPFA，时间复杂度$O(FVE)$，其中$F$是总流量。

#### 最小费用最大流实现（SPFA）（$O(FVE)$）
```cpp
/*
 * Source of the problem: https://www.luogu.com.cn/problem/P3381
 * File: P3381 【模板】最小费用最大流.cpp
 * File Created: Thursday, 2025-09-11 18:32:01
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 * Time: 222 ms
 */
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const ll INF = 1e18;

struct Edge {
    int to, rev;
    ll cap, cost;

    Edge(int to_, int rev_, ll cap_, ll cost_)
        : to(to_), rev(rev_), cap(cap_), cost(cost_) {}
};

// 增加边和反向边
void add_edge(vector<vector<Edge>>& g, int u, int v, ll cap, ll cost) {
    g[u].push_back({v, (int)g[v].size(), cap, cost});
    g[v].push_back({u, (int)g[u].size() - 1, 0, -cost});
}

bool spfa(const vector<vector<Edge>>& g, int s, int t, vector<ll>& dis, vector<int>& pre, vector<int>& pre_edge) {
    int n = g.size() - 1;   // 顶点编号从 1 开始
    dis.assign(n + 1, INF);
    pre.assign(n + 1, -1);
    pre_edge.assign(n + 1, -1);
    vector<bool> in_queue(n + 1, false);
    queue<int> q;

    dis[s] = 0;
    q.push(s);
    in_queue[s] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;

        for (int i = 0; i < g[u].size(); ++i) {
            int v = g[u][i].to;
            ll cap = g[u][i].cap, cost = g[u][i].cost;
            if (cap > 0 && dis[u] + cost < dis[v]) {
                dis[v] = dis[u] + cost;
                pre[v] = u;
                pre_edge[v] = i;
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                }
            }
        }
    }
    return dis[t] != INF;
}

// 返回值为 {最大流, 最小费用}
pair<ll, ll> min_cost_max_flow(vector<vector<Edge>>& g, int s, int t) {
    ll flow = 0, cost = 0;
    vector<ll> dis;
    vector<int> pre, pre_edge;

    while (spfa(g, s, t, dis, pre, pre_edge)) {
        ll f = INF; // 当前增广路径上的最小剩余容量
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v]; // u -> v
            int e = pre_edge[v];    // u -> v 这条边在 u 的邻接表中的位置
            f = min(f, g[u][e].cap);
        }
        // 沿增广路径修改残量网络
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            g[u][e].cap -= f;
            g[v][g[u][e].rev].cap += f;
            cost += f * g[u][e].cost;
        }
        flow += f;
    }
    return {flow, cost};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, s, t;
    cin >> n >> m >> s >> t;
    vector<vector<Edge>> g(n + 1); // 顶点编号从 1 开始

    for (int i = 0; i < m; ++i) {
        int u, v;
        ll cap, cost;
        cin >> u >> v >> cap >> cost;
        add_edge(g, u, v, cap, cost);
    }

    auto [max_flow, min_cost] = min_cost_max_flow(g, s, t);

    cout << max_flow << ' ' << min_cost << '\n';

    return 0;
}
```

#### 最小费用最大流实现（Dijkstra+势函数）（$O(VElog V)$）
```cpp
/*
 * Source of the problem: https://www.luogu.com.cn/problem/P3381
 * File: P3381 dijkstra实现.cpp
 * File Created: Thursday, 2025-09-11 19:42:26
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 * Time: 188 ms
 */
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const ll INF = 1e18;

struct Edge {
    int to, rev;
    ll cap, cost;
    
    Edge(int to_, int rev_, ll cap_, ll cost_)
        : to(to_), rev(rev_), cap(cap_), cost(cost_) {}
};

void add_edge(vector<vector<Edge>>& g, int u, int v, ll cap, ll cost) {
    g[u].push_back({v, (int)g[v].size(), cap, cost});
    g[v].push_back({u, (int)g[u].size() - 1, 0, -cost});
}

bool dijkstra(const vector<vector<Edge>>& g, int s, int t, 
              vector<ll>& h, vector<ll>& dis, vector<int>& pre, vector<int>& pre_edge) {
    int n = g.size() - 1;
    dis.assign(n + 1, INF);
    pre.assign(n + 1, -1);
    pre_edge.assign(n + 1, -1);
    
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    
    dis[s] = 0;
    pq.push({0, s});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dis[u]) continue;
        
        for (int i = 0; i < g[u].size(); ++i) {
            int v = g[u][i].to;
            ll cap = g[u][i].cap;
            ll cost = g[u][i].cost + h[u] - h[v]; // 使用势函数调整后的费用
            
            if (cap > 0 && dis[u] + cost < dis[v]) {
                dis[v] = dis[u] + cost;
                pre[v] = u;
                pre_edge[v] = i;
                pq.push({dis[v], v});
            }
        }
    }
    
    return dis[t] != INF;
}

bool spfa_init(const vector<vector<Edge>>& g, int s, vector<ll>& h) {
    int n = g.size() - 1;
    h.assign(n + 1, INF);
    vector<bool> in_queue(n + 1, false);
    vector<int> cnt(n + 1, 0);
    queue<int> q;
    
    h[s] = 0;
    q.push(s);
    in_queue[s] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;
        
        if (++cnt[u] > n) return false; // 检测负环
        
        for (const auto& e : g[u]) {
            int v = e.to;
            if (e.cap > 0 && h[u] + e.cost < h[v]) {
                h[v] = h[u] + e.cost;
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                }
            }
        }
    }
    return true;
}

pair<ll, ll> min_cost_max_flow(vector<vector<Edge>>& g, int s, int t) {
    ll flow = 0, cost = 0;
    vector<ll> h, dis;
    vector<int> pre, pre_edge;
    
    // 初始化势函数（处理负权边）
    if (!spfa_init(g, s, h)) {
        return {-1, -1}; // 存在负环，无解
    }
    
    while (dijkstra(g, s, t, h, dis, pre, pre_edge)) {
        // 更新势函数
        for (int i = 1; i < h.size(); ++i) {
            if (dis[i] != INF) {
                h[i] += dis[i];
            }
        }
        
        ll f = INF;
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            f = min(f, g[u][e].cap);
        }
        
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            g[u][e].cap -= f;
            g[v][g[u][e].rev].cap += f;
            cost += f * g[u][e].cost;
        }
        
        flow += f;
    }
    
    return {flow, cost};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, s, t;
    cin >> n >> m >> s >> t;
    vector<vector<Edge>> g(n + 1);
    
    for (int i = 0; i < m; ++i) {
        int u, v;
        ll cap, cost;
        cin >> u >> v >> cap >> cost;
        add_edge(g, u, v, cap, cost);
    }
    
    auto [max_flow, min_cost] = min_cost_max_flow(g, s, t);
    
    cout << max_flow << ' ' << min_cost << '\n';
    
    return 0;
}
```

#### 有流量上限的最小费用最大流
时间复杂度$O(VE + F × (V + E) log V)$，其中$F$是流量上限。
```cpp
/*
 * Source of the problem: https://atcoder.jp/contests/practice2/tasks/practice2_e
 * File: E - MinCostFlow.cpp
 * File Created: Thursday, 2025-09-11 19:50:37
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 * Time: 76 ms
 */
#include <iostream>
#include <vector>
#include <queue>

using namespace std;
using ll = long long;

const ll INF = 1e18;

struct Edge {
    int to, rev;
    ll cap, cost;
    
    Edge(int to_, int rev_, ll cap_, ll cost_)
        : to(to_), rev(rev_), cap(cap_), cost(cost_) {}
};

void add_edge(vector<vector<Edge>>& g, int u, int v, ll cap, ll cost) {
    g[u].push_back({v, (int)g[v].size(), cap, cost});
    g[v].push_back({u, (int)g[u].size() - 1, 0, -cost});
}

bool dijkstra(const vector<vector<Edge>>& g, int s, int t, 
              vector<ll>& h, vector<ll>& dis, vector<int>& pre, vector<int>& pre_edge) {
    int n = g.size() - 1;
    dis.assign(n + 1, INF);
    pre.assign(n + 1, -1);
    pre_edge.assign(n + 1, -1);
    
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    
    dis[s] = 0;
    pq.push({0, s});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dis[u]) continue;
        
        for (int i = 0; i < g[u].size(); ++i) {
            int v = g[u][i].to;
            ll cap = g[u][i].cap;
            ll cost = g[u][i].cost + h[u] - h[v]; // 使用势函数调整后的费用
            
            if (cap > 0 && dis[u] + cost < dis[v]) {
                dis[v] = dis[u] + cost;
                pre[v] = u;
                pre_edge[v] = i;
                pq.push({dis[v], v});
            }
        }
    }
    
    return dis[t] != INF;
}

bool spfa_init(const vector<vector<Edge>>& g, int s, vector<ll>& h) {
    int n = g.size() - 1;
    h.assign(n + 1, INF);
    vector<bool> in_queue(n + 1, false);
    vector<int> cnt(n + 1, 0);
    queue<int> q;
    
    h[s] = 0;
    q.push(s);
    in_queue[s] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;
        
        if (++cnt[u] > n) return false; // 检测负环
        
        for (const auto& e : g[u]) {
            int v = e.to;
            if (e.cap > 0 && h[u] + e.cost < h[v]) {
                h[v] = h[u] + e.cost;
                if (!in_queue[v]) {
                    q.push(v);
                    in_queue[v] = true;
                }
            }
        }
    }
    return true;
}

// 流量不超过 max_flow_limit 的最小费用最大流
pair<ll, ll> min_cost_flow_limited(vector<vector<Edge>>& g, int s, int t, ll max_flow_limit) {
    ll flow = 0, cost = 0;
    vector<ll> h, dis;
    vector<int> pre, pre_edge;
    
    // 初始化势函数（处理负权边）
    if (!spfa_init(g, s, h)) {
        return {-1, -1}; // 存在负环，无解
    }
    
    while (flow < max_flow_limit && dijkstra(g, s, t, h, dis, pre, pre_edge)) {
        // 更新势函数
        for (int i = 1; i < h.size(); ++i) {
            if (dis[i] != INF) {
                h[i] += dis[i];
            }
        }
        
        ll f = max_flow_limit - flow; // 剩余可流的量
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            f = min(f, g[u][e].cap);
        }
        
        // 检查是否值得增加这个流
        ll path_cost = 0;
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            path_cost += g[u][e].cost;
        }
        
        // 如果路径费用非负，且不是必须的流，则停止
        if (path_cost >= 0 && flow > 0) {
            break;
        }
        
        for (int v = t; v != s; v = pre[v]) {
            int u = pre[v];
            int e = pre_edge[v];
            g[u][e].cap -= f;
            g[v][g[u][e].rev].cap += f;
            cost += f * g[u][e].cost;
        }
        
        flow += f;
    }
    
    return {flow, cost};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, k;
    cin >> n >> k;

    // [1, n] 左侧节点, [n+1, 2n] 右侧节点, 2n+1 源点, 2n+2 汇点
    vector<vector<Edge>> g(2 * n + 3);

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            ll cost;
            cin >> cost;
            add_edge(g, i, n + j, 1, -cost);
        }
    }

    int st = 2 * n + 1, ed = 2 * n + 2;
    for (int i = 1; i <= n; ++i) {
        add_edge(g, st, i, k, 0); // 源点到左侧节点
        add_edge(g, n + i, ed, k, 0); // 右侧节点到汇点
    }

    auto [flow, cost] = min_cost_flow_limited(g, st, ed, INF);

    vector<vector<char> > ans(n + 1, vector<char>(n + 1, '.'));
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (g[i][j].cap == 0) ans[i][j + 1] = 'X';
        }
    }

    cout << -cost << '\n';
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cout << ans[i][j];
        }
        cout << '\n';
    }
    
    return 0;
}
```


### SCC + 拓扑排序
```cpp
/*
 * Source of the problem: Unknow
 * File: G - SCC.cpp
 * File Created: Wednesday, 2025-09-10 15:28:24
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 * Time: 317 ms
 */
#include <iostream>
#include <vector>
#include <stack>
#include <queue>

using namespace std;

int idx = 1;    // 顶点遍历顺序，从 1 开始

void tarjan(const vector<vector<int> > &g, vector<int> &dfn, vector<int> &low, stack<int> &stk, vector<vector<int> > &scc, vector<int> &belong, vector<int> &instk, int cur) {
    stk.push(cur);
    dfn[cur] = low[cur] = idx++;
    instk[cur] = 1;
    for (int i = 0; i < g[cur].size(); ++i) {
        int v = g[cur][i];
        if (v == cur) continue; // 忽略自环（没影响）
        if (!dfn[v]) {  // 没访问过
            tarjan(g, dfn, low, stk, scc, belong, instk, v);
            low[cur] = min(low[cur], low[v]);
        }
        else if (instk[v]) low[cur] = min(low[cur], dfn[v]);
    }
    if (low[cur] == dfn[cur]) {
        scc.push_back(vector<int>());
        while (!stk.empty()) {
            int v = stk.top();
            stk.pop();
            instk[v] = false;
            scc.back().push_back(v);
            belong[v] = scc.size() - 1;
            if (v == cur) break;
        }
    }
}

vector<int> tsort(const vector<vector<int> > &g, const vector<vector<int> > &scc, const vector<int> &belong) {
    int n = g.size(), m = scc.size();
    int id = 0;
    vector<int> in_cnt(m, 0);
    vector<int> res(m, 0);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < g[i].size(); ++j) {
            if(belong[i] != belong[g[i][j]]) in_cnt[belong[g[i][j]]]++;
        }
    }
    queue<int> q;
    for (int i = 0; i < m; ++i) {
        if (in_cnt[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        res[id] = u;
        id++;
        for (int i = 0; i < scc[u].size(); ++i) {
            for (int v : g[scc[u][i]]) {
                in_cnt[belong[v]]--;
                if (in_cnt[belong[v]] == 0) q.push(belong[v]);
            }
        }
    }

    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, a, b;
    cin >> n >> m;
    vector<vector<int> > g(n + 1);
    for (int i = 0; i < m; ++i) {
        cin >> a >> b;
        g[a].push_back(b);
    }
    vector<int> belong(n), instk(n, 0), dfn(n), low(n);
    vector<vector<int> > scc;
    stack<int> stk;

    for (int i = 0; i < n; ++i) {
        if (!dfn[i]) tarjan(g, dfn, low, stk, scc, belong, instk, i);
    }
    vector<int> sorted = tsort(g, scc, belong);

    cout << scc.size() << '\n';
    for (int i = 0; i < sorted.size(); ++i) {
        cout << scc[sorted[i]].size() << ' ';
        for (int j = 0; j < scc[sorted[i]].size(); ++j) cout << scc[sorted[i]][j] << ' ';
        cout << '\n'; 
    }

    return 0;
}
```