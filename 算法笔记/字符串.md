## 字符串

### 1 字符串哈希

- [字符串哈希](https://oi-wiki.org/string/hash/) 是一种将字符串映射到整数的技术，常用于字符串比较、查找和去重。

#### 1.1 哈希函数设计
- 哈希函数通常使用一个大质数作为基数，结合模运算来减少冲突。
- 例如，使用多项式哈希函数：
    $$h(s) = (s[0] \cdot p^{n-1} + s[1] \cdot p^{n-2} + s[2] \cdot p^{n-3} + \ldots + s[n-1] \cdot p^0) \mod m$$

    $$h(s) = (s[0] \cdot p^0 + s[1] \cdot p^1 + s[2] \cdot p^2 + \ldots + s[n-1] \cdot p^{n-1}) \mod m$$
- 其中 $p$ 通常为质数如 31、101、1009、131、13331 等，$m$ 是模数如 $10^9+7$、$10^9+9$ 等，$s[i]$ 是字符串的第 $i$ 个字符的 ASCII 值。

- c++ 示例
```cpp
const long long P = 31;             // 基数
const long long MOD = 1e9 + 7;      // 大模数

long long hash(const string &s) {   // 前缀哈希
    long long h = 0;
    for (char c : s) {
        h = (h * P + c) % MOD;      // 假设字符串只包含小写字母
    }
    return h;
}
```

#### 1.2 子串哈希
- 为了高效计算子串的哈希值，可以预先计算前缀哈希值。
- 前缀哈希值数组 `hash[i]` 表示字符串 `s[0]` 到 `s[i-1]` 的哈希值，即
    $$hash[i] = (s[0] \cdot p^{i-1} + s[1] \cdot p^{i-2} + \ldots + s[i-1] \cdot p^0) \mod m$$
- 子串 `s[l..r]` 的哈希值可以通过以下公式计算（注意索引）：
    $$hash(s[l..r]) = (hash[r+1] - hash[l] \cdot p^{r-l+1}) \mod m$$

- c++ 示例
```cpp
const long long P = 23;             // 基数
const long long MOD = 1e9 + 7;      // 大模数

long long ksm(long long a, long long n, long long mod) { // 快速幂
    long long res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

vector<long long> precompute_hash(const string &s) {
    int n = s.size();
    vector<long long> hash(n + 1, 0);   // h[i] 表示 s[0..i-1] 的哈希值
    for (int i = 0; i < n; i++) {
        hash[i + 1] = (hash[i] * P + s[i]) % MOD;  // 前缀哈希
    }
    return hash;
}

long long substring_hash(const vector<long long> &hash, int l, int r) {
    long long h = (hash[r + 1] - hash[l] * ksm(P, r - l + 1, MOD) % MOD + MOD) % MOD;
    return h;
}
```


### 2 Manacher

- [Manacher](https://oi-wiki.org/string/manacher/) 算法用于求解字符串中的最长回文子串。

- c++示例
```cpp
// 返回字符串 s 的最长回文子串的长度（不包含 #）
int manacher(const string &s) {
    vector<char> t;
    // s = s + '#'+ c 较慢
    for (char c : s) {
        t.push_back('#');
        t.push_back(c);
    }
    t.push_back('#');
    int n = t.size();
    vector<int> p(n, 0);
    int mx = 0, id = 0;
    for (int i = 0; i < n; i++) {
        if (i < mx) p[i] = min(p[2 * id - i], mx - i);
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && t[i + p[i] + 1] == t[i - p[i] - 1]) p[i]++;
        if (i + p[i] > mx) {
            mx = i + p[i];
            id = i;
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, p[i]);
    }
    return ans;
}
```

- 最长回文后缀
```cpp
// 返回字符串 s 的最长回文后缀的长度，找前缀就 reverse 一下（不包含 #）
int manacher_suffix(const string &s) {
    vector<char> t;
    for (char c : s) {
        t.push_back('#');
        t.push_back(c);
    }
    t.push_back('#');
    int n = t.size(), ans = 0;
    vector<int> p(n, 0);
    int mx = 0, id = 0;
    for (int i = 0; i < n; i++) {
        if (i < mx) p[i] = min(p[2 * id - i], mx - i);
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && t[i + p[i] + 1] == t[i - p[i] - 1]) p[i]++;
        if (i + p[i] > mx) {
            mx = i + p[i];
            id = i;
        }
        if (i + p[i] == n - 1) {
            ans = max(ans, p[i]);
        }
    }
    return ans;
}
```

### 3 朴素的字符串匹配（Brute Force, BF）
- c++示例
```cpp
// 返回第一个匹配的位置，不匹配则返回 -1，时间复杂度 O(nm)
int bf(const string &s, const string &p) {
    if (p.empty()) return -1;   //
    int i = 0, j = 0;
    for (i = 0; i + p.size() <= s.size(); i++, j = i) {
        while (j < p.size() && s[i + j] == p[j]) j++;
        if (j == p.size()) return i;
    }
    return -1;
}
```

### 4 KMP 算法
- [KMP](https://oi-wiki.org/string/kmp/) 算法用于字符串匹配，核心是前缀函数（或称为失配函数）。

#### 4.1 前缀函数
- 前缀函数 `pi[i]` 表示字符串 `s[0..i]` 的最长相等前后缀的长度（真前后缀）。
- 用数学公式表示如下：
    $$\pi[i] = \max\{k \mid s[0..k-1] = s[i-k+1..i]\}$$

- 前缀函数的计算可以通过动态规划实现，时间复杂度为 $O(n)$。
- c++ 示例
```cpp
vector<int> prefix_function(const string &s) {
    int n = s.size();
    vector<int> pi(n, 0);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[j] == s[i]) j++;  // 不成立时 j = 0，最长公共前后缀为 0
        pi[i] = j;
    }
    return pi;
}
```

#### 4.2 KMP 匹配
- KMP 匹配算法利用前缀函数来避免重复比较，时间复杂度为 $O(n + m)$。
- c++ 示例
```cpp
// 返回第一个匹配的位置，不匹配则返回 -1
int kmp(const string &s, const string &p) {
    if (p.empty()) return -1;   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) return i - m + 1; // 完全匹配，返回起始位置
    }
    return -1; // 没有匹配
}

// 返回所有匹配的位置
vector<int> kmp_all(const string &s, const string &p) {
    if (p.empty()) return {};   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    vector<int> result;
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) {
            result.push_back(i - m + 1); // 完全匹配，记录起始位置
            j = pi[j - 1]; // 准备寻找下一个匹配
        }
    }
    return result; // 返回所有匹配的位置
}

// 返回所有匹配的位置（不重叠）
vector<int> kmp_non_overlap(const string &s, const string &p) {
    if (p.empty()) return {};   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    vector<int> result;
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) {
            result.push_back(i - m + 1); // 完全匹配，记录起始位置
            j = 0; // 重置 j，避免重叠
        }
    }
    return result; // 返回所有匹配的位置
}
```

### 5 Z 函数（扩展 KMP）

- [Z 函数](https://oi-wiki.org/string/z-func/) 是一个字符串处理算法，用于快速计算字符串的匹配信息。

#### 5.1 一些约定
约定：字符串下标从 0 开始。


#### 5.2 Z 函数定义
- 对于长度为 n 的字符串 `s`，Z 函数 `z[i]` 表示 `s` 与 `s[i, n-1]` 的最长公共前缀长度。特别地，`z[0]` 通常定义为 0。
- 形式化定义为：
    $$z[i] = \max\{k \mid s[0..k-1] = s[i..i+k-1]\}$$
- 国外一般将计算 z 数组的算法称为 Z-algorithm，国内也成为扩展 KMP 算法。

#### 5.3 样例解释

- $z[aaaaa] = [0, 4, 3, 2, 1]$
- 解释：
    - `z[0]` = 0，通常约定如此，因为没有意义比较字符串与自身。
    - `z[1]` = 4，因为 `s[0, 4]` 与 `s[1, 4]` 的最长公共前缀是 `aaaa`，长度为 4。
    - `z[2]` = 3，因为 `s[0, 4]` 与 `s[2, 4]` 的最长公共前缀是 `aaa`，长度为 3。
    - `z[3]` = 2，因为 `s[0, 4]` 与 `s[3, 4]` 的最长公共前缀是 `aa`，长度为 2。
    - `z[4]` = 1，因为 `s[0, 4]` 与 `s[4, 4]` 的最长公共前缀是 `a`，长度为 1。
- $z[aabab] = [0, 1, 0, 1, 0]$
- 解释：
    - `z[0]` = 0，通常约定如此。
    - `z[1]` = 1，因为 `s[0, 4]` 与 `s[1, 4]` 的最长公共前缀是 `a`，长度为 1。
    - `z[2]` = 0，因为 `s[0, 4]` 与 `s[2, 4]` 没有公共前缀。
    - `z[3]` = 1，因为 `s[0, 4]` 与 `s[3, 4]` 的最长公共前缀是 `a`，长度为 1。
    - `z[4]` = 0，因为 `s[0, 4]` 与 `s[4, 4]` 没有公共前缀。
- $z[ababa] = [0, 0, 3, 0, 1]$

#### 5.4 朴素算法
- 朴素算法的时间复杂度为 $O(n^2)$，对于每个位置 $i$，直接比较 `s[0..n-1]` 和 `s[i..n-1]` 的最长公共前缀。
- c++ 示例
```cpp
vector<int> z_function_naive(const string &s) {
    int n = s.size();
    vector<int> z(n, 0);
    for (int i = 1; i < n; i++) {
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
    }
    return z;
}
```

#### 5.5 线性算法
- 借助之前的计算结果，可以加速计算 Z 函数，使用时间复杂度降为 $O(n)$。
- 对于 i，称区间`[i, i + z[i] - 1]`是 i 的匹配段，也可以叫做 `Z-box`。
- 在计算过程中，我们维护一个右端点最靠右的匹配段，记作`[l, r]`，初始时为`[0, 0]`。
- 在计算 z[i] 时：
    1. 如果 i <= r（即 i 在前面的某个匹配段内）：
        1. 若 `z[i - l] < r - i + 1`，则 `z[i] = z[i - l]`。
        2. 否则，z[i] = r - i + 1，然后枚举下一个字符拓展 z[i]。
    1. 如果 i > r，直接按照朴素算法计算 z[i]。
- 更新`[l, r]`。
- c++ 示例
```cpp
vector<int> z_function(const string &s) {
    int n = s.size();
    vector<int> z(n, 0);
    int l = 0, r = 0; // 匹配段的左右端点
    for (int i = 1; i < n; i++) {
        if (i <= r) {
            z[i] = min(r - i + 1, z[i - l]); // 在匹配段内
        }
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {    // 尝试拓展 z[i]
            z[i]++;
        }
        if (i + z[i] - 1 > r) { // 更新匹配段
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```


### 6 Trie 树
- [Trie 树](https://oi-wiki.org/string/trie/) 是一种高效的字符串存储结构，常用于前缀匹配、自动补全等场景。

#### 6.1 Trie 树的定义
- Trie 树是一种多叉树，每个节点表示一个字符，路径从根节点到某个节点表示一个字符串。
- 每个节点包含一个 `children` 数组，表示所有可能的子节点。（可以使用哈希表或 unordered_map 来支持任意字符集）
- 每个节点还可以包含一个 `is_end` 标志，表示是否有字符串以该节点结尾。
- Trie 树的根节点通常不存储字符。

#### 6.2 Trie 树的典型应用
- **前缀匹配**：快速查找以某个前缀开头的字符串。
- **自动补全**：根据输入的前缀，快速找到所有可能的后缀。
- **字符串去重**：通过插入字符串到 Trie 树中，可以自动去除重复的字符串。
- **字符串统计**：可以统计某个字符串在 Trie 树中出现的次数。
- **字符串搜索**：可以快速判断某个字符串是否存在于 Trie 树中。
- **字符串最长公共前缀**：可以快速找到多个字符串的最长公共前缀。

#### 6.3 Trie 树的实现
- c++ 示例
```cpp
// Times of testing: 1
struct TrieNode {
    TrieNode *children[26]; // 假设只包含小写字母
    bool is_end;            // 是否为某个字符串的结尾

    TrieNode() : is_end(false) {
        fill(begin(children), end(children), nullptr);
    }
};
class Trie {
private:
    TrieNode *root;
public:
    Trie() {
        root = new TrieNode();
    }
    void insert(const string &word) {
        TrieNode *node = root;
        for (char c : word) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                node->children[index] = new TrieNode();
            }
            node = node->children[index];
        }
        node->is_end = true; // 标记字符串结尾
    }
    bool search(const string &word) {
        TrieNode *node = root;
        for (char c : word) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                return false; // 不存在
            }
            node = node->children[index];
        }
        return node->is_end; // 返回是否为字符串结尾
    }
    bool startsWith(const string &prefix) {
        TrieNode *node = root;
        for (char c : prefix) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                return false; // 不存在前缀
            }
            node = node->children[index];
        }
        return true; // 前缀存在
    }
    void clear(TrieNode *node) {
        if (!node) return;
        for (int i = 0; i < 26; i++) {
            clear(node->children[i]);
        }
        delete node;
    }
    ~Trie() {
        clear(root); // 清理内存
    }
};
// 使用示例
int main() {
    Trie trie;
    trie.insert("hello");
    trie.insert("world");
    cout << trie.search("hello") << endl; // 输出 1
    cout << trie.search("hell") << endl;  // 输出 0
    cout << trie.startsWith("he") << endl; // 输出 1
    cout << trie.startsWith("wo") << endl; // 输出 1
    return 0;
}
```

#### 6.4 支持任意字符集的 Trie 树
- 如果需要支持任意字符集，可以使用哈希表或 unordered_map 来存储子节点。
- 使用 `wchar_t` 或 `char32_t` 等类型来表示 Unicode 字符。
- c++ 示例
```cpp
// Times of testing: 1
#include <iostream>
#include <string>
#include <map>
#include <vector>
using namespace std;

// Trie 节点
struct TrieNode {
    map<char32_t, TrieNode*> children; // 使用 map 存储子节点，键为 Unicode 字符
    bool is_end;                       // 是否为字符串结尾

    TrieNode() : is_end(false) {}
};

// 将 UTF-8 字符串转换为 Unicode 字符序列
vector<char32_t> utf8_to_unicode(const string& str) {
    vector<char32_t> result;
    size_t i = 0;
    while (i < str.size()) {
        char32_t codepoint = 0;
        // 0x80 = 10000000 检查最高位知否为 0
        if ((str[i] & 0x80) == 0) { // 1 字节 (ASCII)
            codepoint = str[i];
            i += 1;
        } else if ((str[i] & 0xE0) == 0xC0) { // 2 字节
            codepoint = ((str[i] & 0x1F) << 6) | (str[i + 1] & 0x3F);
            i += 2;
        } else if ((str[i] & 0xF0) == 0xE0) { // 3 字节（中文常用）
            codepoint = ((str[i] & 0x0F) << 12) | ((str[i + 1] & 0x3F) << 6) | (str[i + 2] & 0x3F);
            i += 3;
        } else if ((str[i] & 0xF8) == 0xF0) { // 4 字节
            codepoint = ((str[i] & 0x07) << 18) | ((str[i + 1] & 0x3F) << 12) |
                        ((str[i + 2] & 0x3F) << 6) | (str[i + 3] & 0x3F);
            i += 4;
        }
        result.push_back(codepoint);
    }
    return result;
}

// Trie 类
class Trie {
private:
    TrieNode* root;

    // 递归清理内存
    void clear(TrieNode* node) {
        if (!node) return;
        for (auto& child : node->children) {
            clear(child.second);
        }
        delete node;
    }

public:
    Trie() {
        root = new TrieNode();
    }

    // 插入字符串
    void insert(const string& word) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(word);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->is_end = true;
    }

    // 查找字符串
    bool search(const string& word) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(word);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        return node->is_end;
    }

    // 查找前缀
    bool startsWith(const string& prefix) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(prefix);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        return true;
    }

    // 析构函数
    ~Trie() {
        clear(root);
    }
};

// 使用示例
int main() {
    Trie trie;
    trie.insert("你好");
    trie.insert("世界");
    cout << trie.search("你好") << endl;    // 输出 1
    cout << trie.search("你") << endl;      // 输出 0
    cout << trie.startsWith("世") << endl;  // 输出 1
    cout << trie.startsWith("你好") << endl; // 输出 1
    return 0;
}
```

#### 6.5 Trie 树快速实现（竞赛模板）
- 下面是一个简化的 Trie 树实现，支持插入、查找和前缀匹配。
```cpp
// Times of testing: 2
// 假设只包含小写字母
const int N = 1e6 + 5;
int trie[N][26];    // Trie 树
int cnt[N];         // 记录每个节点的字符串数量
int pass[N];        // 每个节点被经过的次数（前缀匹配）
int idx = 0;        // 当前已使用的节点的索引

void insert(const string &s) {
    int node = 0; // 从根节点开始
    if (s.empty()) return; // 空字符串不插入
    pass[0]++; // 根节点被经过一次
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) {
            trie[node][index] = ++idx; // 创建新节点
        }
        node = trie[node][index]; // 移动到子节点
        pass[node]++; // 更新前缀匹配次数
    }
    cnt[node]++; // 更新字符串数量
}

bool search(const string &s) {
    int node = 0; // 从根节点开始
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) return false; // 如果子节点不存在，返回 false
        node = trie[node][index];
    }
    return cnt[node] > 0;
}

bool remove(const string &s) {
    int node = 0;
    stack<int> stk; // 记录路径上的节点
    stk.push(node);
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) return false; // 字符串不存在
        node = trie[node][index];
        stk.push(node);
    }
    if (cnt[node] == 0) return false; // 字符串不存在
    cnt[node]--; // 减少字符串计数
    while (!stk.empty()) {
        pass[stk.top()]--; // 更新前缀计数
        stk.pop();
    }
    return true;
}
```

### 7 AC自动机
- [AC自动机](https://oi-wiki.org/string/ac-automaton/)
- AC 自动机是一种高效的字符串匹配算法，常用于多模式匹配。
- 它结合了 Trie 树和 KMP 算法的思想，能够在 O(n + m) 的时间复杂度内处理多个模式串的匹配。

#### 7.1 失败指针（Fail Pointer）
- 在 Trie 树的基础上，AC 自动机为每个节点添加一个失败指针（Fail Pointer），用于在匹配失败时快速跳转到下一个可能的匹配位置。
- 失败指针指向当前节点的最长后缀匹配节点。
- 失败指针用于在匹配过程中，当当前字符不匹配时，可以通过失败指针快速找到下一个可能的匹配位置，而不需要回溯到根节点。

#### 7.2 构建 AC 自动机
##### 7.2.1 构建 Trie 树
首先将所有模式串插入到 Trie 树中。

##### 7.2.1 构建失败指针
使用 BFS 遍历 Trie 树，构建失败指针。
```c++
void build_fail() {
    queue<int> q;
    for (int i = 0; i < M; i++) {
        if (t[0].son[i]) {
            t[t[0].son[i]].fail = 0;
            q.push(t[0].son[i]);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // 可在此记录拓扑排序
        for (int i = 0; i < M; i++) {
            if (t[u].son[i]) {
                int v = t[u].son[i];
                t[v].fail = t[t[u].fail].son[i];
                // t[v].cnt += t[t[v].fail].cnt;
                q.push(v);
            }
            else t[u].son[i] = t[t[u].fail].son[i];
        }
    }
}
```

#### 7.3 计算多个模式串在文本中的出现次数（c++ 示例）
```cpp
/*
 * Source of the problem: Unknow
 * File: B - AC 自动机.cpp
 * File Created: Saturday, 2025-07-19 13:41:17
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 */
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int N = 1e6 + 5;
const int M = 26;

struct Node {
    int son[M], fail;
    int in_degree; // 入度
    int cnt; // 匹配次数
    vector<int> ids; // 模式串的 ID
    Node() : fail(0), cnt(0), in_degree(0) {
        fill(son, son + M, 0);
    }
};

int idx = 0;
int ans[N];
Node trie[N];

// 插入字符串到 AC 自动机
void insert(const string &s, int id) {
    int p = 0;
    for (char c : s) {
        int u = c - 'a';
        if (!trie[p].son[u]) {
            trie[p].son[u] = ++idx;
        }
        p = trie[p].son[u];
    }
    trie[p].ids.push_back(id); // 记录该节点的模式串 ID
}

// 构建 AC 自动机的失败指针
void build() {
    queue<int> q;
    for (int i = 0; i < M; i++) {
        if (trie[0].son[i]) {
            trie[trie[0].son[i]].fail = 0;
            q.push(trie[0].son[i]);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int i = 0; i < M; i++) {
            if (trie[u].son[i]) {
                int v = trie[u].son[i];
                trie[v].fail = trie[trie[u].fail].son[i];
                q.push(v);
                // 更新入度
                trie[trie[v].fail].in_degree++;
            }
            else {
                trie[u].son[i] = trie[trie[u].fail].son[i];
            }
        }
    }
}

void query(const string &s) {
    int p = 0;
    for (char c : s) {
        int u = c - 'a';
        p = trie[p].son[u];
        trie[p].cnt++; // 统计匹配次数
    }
}

void propagate() {
    queue<int> q;
    for (int i = 0; i <= idx; i++) {
        if (trie[i].in_degree == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (auto id : trie[u].ids) {
            ans[id] += trie[u].cnt; // 累加匹配次数
        }
        int v = trie[u].fail;
        if (v != 0) {
            trie[v].cnt += trie[u].cnt; // 将当前节点的匹配次数传递给失败指针
            trie[v].in_degree--; // 减少入度
            if (trie[v].in_degree == 0) {
                q.push(v); // 如果入度为 0，加入队列
            }
        }
    }
}

int main() {
    int n;
    string s, t;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s;
        insert(s, i + 1);
    }
    build();
    cin >> t;
    query(t);
    propagate();

    for (int i = 1; i <= n; i++) {
        cout << ans[i] << endl;
    }

    return 0;
}
```



### 8 后缀数组（Suffix Array，SA）
- [后缀数组](https://oi-wiki.org/string/sa/) 是一种高效的字符串处理数据结构，用于解决字符串的各种问题，如子串查找、最长公共前缀等。

#### 8.1 一些约定
- 字符串下标从 $1$ 开始
- 字符串 $s$ 的大小为 $n$


#### 8.2 后缀数组的应用

1. **子串查找**：
    - 后缀数组通过将字符串的所有后缀按字典序排序，可以利用二分查找快速定位某个子串是否存在于原字符串中。时间复杂度为 $O(|P| + log |S|)$，其中 $|P|$ 为模式串长度，$|S|$ 为原字符串长度（在利用 LCP 优化的情况下）。朴素实现的时间复杂度为 $O(|P| * log |S|)$，但通过 `height` 数组等优化可显著降低比较开销。
    - 应用场景：字符串匹配、模式查询（如正则表达式引擎）。


2. **最长公共前缀（LCP）查询**：
    - 结合 `height` 数组，后缀数组可以高效计算任意两个后缀的最长公共前缀。利用 RMQ（Range Minimum Query）数据结构，LCP 查询时间复杂度可优化至 O(1)。
    - 应用场景：比较两个子串的相似性、DNA 序列分析。


1. **最长重复子串**：
    - 通过 `height` 数组，找到最大值即可得到字符串中最长的重复子串（即 `height[i]` 的最大值对应的子串）。
    - 应用场景：文本压缩、数据去重。


1. **最长回文子串**：
    - 通过构造原字符串和其逆序字符串的拼接，并利用后缀数组和 LCP，可以快速找到最长的回文子串。
    - 应用场景：回文检测、生物信息学。


1. **字符串统计**：
    - 后缀数组可用于统计字符串中不同子串的个数，通过计算 `height` 数组的差值，得到唯一子串的数量，时间复杂度为 O(n)。
    - 应用场景：文本分析、搜索引擎优化。

1. **最长公共子串**：
    - 后缀数组可以计算两个字符串的最长公共子串，通过构造两个字符串的拼接后缀数组，并利用 `height` 数组找到最大值。
    - 应用场景：DNA 序列比对、版本控制系统中的文件比较。


1. **其他应用**：


#### 8.3 sa、rank、height 数组简介
- **后缀数组（SA）**：
  - **定义**：后缀数组 `sa` 是一个一维数组，存储字符串所有后缀按字典序排序后的起始位置。`sa[i]` 表示排在第 `i` 位的后缀的起始下标。
  - **作用**：通过 `sa` 数组，可以快速访问按字典序排列的后缀，方便解决子串比较、查找等问题。

- **rank 数组**：
  - **定义**：`rank` 数组记录每个后缀在字典序中的排名。`rank[i]` 表示从位置 `i` 开始的后缀在所有后缀中的排名，满足 `sa[rank[i]] = i`。
  - **作用**：`rank` 数组是 `sa` 数组的逆映射，用于快速查询某个后缀的字典序位置。


- **height 数组（LCP 数组）**：
  - **定义**：`height` 数组记录相邻两个后缀在字典序排序中的最长公共前缀（LCP，Longest Common Prefix）。`height[i]` 表示 `sa[i-1]` 和 `sa[i]` 对应后缀的最长公共前缀长度（`height[0]` 通常定义为 0）。
  - **作用**：`height` 数组用于高效计算任意两个后缀的 LCP，广泛应用于字符串匹配、重复子串等问题。


#### 8.4 倍增法计算后缀数组 O(n log n)
- 倍增法是一种高效计算后缀数组的算法，时间复杂度为 $O(n \log n)$。
- 该方法通过对后缀进行排序，逐步增加比较长度，直到所有后缀都被正确排序。
- 具体步骤如下：
  1. **初始化**：将所有后缀的长度初始化为 1，使用 `rank` 数组记录每个后缀的排名。
  2. **排序**：使用计数排序或基数排序对后缀进行排序，比较长度为 $2^k$ 的后缀。
  3. **倍增**：逐步增加比较长度，直到达到字符串长度。


#### 8.5 计算 height 数组
- `height` 数组可以通过后缀数组和 `rank` 数组计算得到，时间复杂度为 $O(n)$。
> 引理：$height[rank[i]] >= height[rank[i - 1]] - 1$，即相邻后缀的 LCP 长度不会小于前一个后缀的 LCP 长度减一。
- 根据引理我们有下面的计算方法：
  1. 初始化 `height` 数组，长度为 $n + 1$。
  2. 使用 `rank` 数组记录每个后缀在后缀数组中的位置。
  3. 遍历后缀数组，计算相邻后缀的 LCP 长度，并更新 `height` 数组。


#### 8.6 c++示例代码
```cpp
// Times of testing: 2
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e6 + 5;

int n, m;
string s;   // 假设只包含 ASCII 码
int sa[N], rk[N<<1], oldrk[N<<1], id[N], cnt[N], height[N];

int main() {
    cin >> s;
    n = s.size();
    s = 'a' + s;    // 索引从 1 开始
    m = 127;    // 最初的值域为 ASCII 码字符集大小
    for (int i = 1; i <= n; i++) cnt[rk[i] = s[i]]++;
    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;
    // rk[i]: 字符 s[i] 的排名
    // cnt[rk[i]]: 小于等于 s[i] 的数量，因此 sa[cnt[rk[i]]] = i
    // cnt[rk[i]]-- 确保下一个相同关键字或更小的后缀放在前一个位置
    memcpy(oldrk + 1, rk + 1, n * sizeof(int));

    for (int p = 0, i = 1; i <= n; i++) {
        if (oldrk[sa[i]] == oldrk[sa[i - 1]]) rk[sa[i]] = p;    // 旧排名相同，新排名也相同
        else rk[sa[i]] = ++p;
    }

    int i, p = 0, k;
    for (int w = 1; w < n; w <<= 1, m = p) {    // m = p: 值域优化
        // 第二关键字计数排序的优化
        int cur = 0;
        for (i = n - w + 1; i <= n; i++) id[++cur] = i; // 第二关键字为 0，放到前面
        for (i = 1; i <= n; i++) if (sa[i] > w) id[++cur] = sa[i] - w;
            

        // 对第一关键字 id[i] 进行计数排序
        memset(cnt, 0, (m + 1) * sizeof(int));
        for (i = 1; i <= n; i++) cnt[rk[id[i]]]++;
        for (i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];

        memcpy(oldrk + 1, rk + 1, n * sizeof(int));
        for (i = 1, p = 0; i <= n; i++) {
            if (oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) rk[sa[i]] = p;
            else rk[sa[i]] = ++p;
        }
        if (p == n) break;  // 排名计算完毕，sa 可能要重新计算
    }
    // 计算 height 数组
    for (i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 0) continue;
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        height[rk[i]] = k;
    }

    return 0;
}
```

#### 8.7 O(n(logn)^2) 实现
```cpp
// Times of testing: 1
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e6 + 5;

int n;
string s;
int sa[N], rk[N<<1], oldrk[N<<1], height[N];

int main() {
    int i, p, k;
    cin >> s;
    n = s.size();
    s = 'a' + s;    // 索引从 1 开始
    for (i = 1; i <= n; i++) {
        sa[i] = i;
        rk[i] = s[i];
    }
    for (int w = 1; w < n; w <<= 1) {
        sort(sa + 1, sa + n + 1, [w] (int x, int y) {
            return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
        });
        // 更新排名
        for (i = 1; i <= n; i++) oldrk[i] = rk[i];
        for (p = 1, i = 1; i <= n; i++) {
            if (oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
                rk[sa[i]] = p;  // 排名相同
            }
            else rk[sa[i]] = ++p;
        }
        // if (p == n) break;  // 计算完成
    }
    // 根据 sa 计算 rk
    for (i = 1; i <= n; i++) rk[sa[i]] = i;
    // 计算 height
    for (i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 0) continue;
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        height[rk[i]] = k;
    }

    for (i = 1; i <= n; i++) cout << sa[i] << ' ';

    return 0;
}
```