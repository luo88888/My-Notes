<!-- TOC -->

## 1 字符串

### 1.1  字符串哈希

- [字符串哈希](https://oi-wiki.org/string/hash/) 是一种将字符串映射到整数的技术，常用于字符串比较、查找和去重。

#### 1.1.1 哈希函数设计
- 哈希函数通常使用一个大质数作为基数，结合模运算来减少冲突。
- 例如，使用多项式哈希函数：
    $$h(s) = (s[0] \cdot p^{n-1} + s[1] \cdot p^{n-2} + s[2] \cdot p^{n-3} + \ldots + s[n-1] \cdot p^0) \mod m$$

    $$h(s) = (s[0] \cdot p^0 + s[1] \cdot p^1 + s[2] \cdot p^2 + \ldots + s[n-1] \cdot p^{n-1}) \mod m$$
- 其中 $p$ 通常为质数如 31、101、1009、131、13331 等，$m$ 是模数如 $10^9+7$、$10^9+9$ 等，$s[i]$ 是字符串的第 $i$ 个字符的 ASCII 值。

- c++ 示例
```cpp
const long long P = 31;             // 基数
const long long MOD = 1e9 + 7;      // 大模数

long long hash(const string &s) {   // 前缀哈希
    long long h = 0;
    for (char c : s) {
        h = (h * P + c) % MOD;      // 假设字符串只包含小写字母
    }
    return h;
}
```

#### 1.1.2 子串哈希
- 为了高效计算子串的哈希值，可以预先计算前缀哈希值。
- 前缀哈希值数组 `hash[i]` 表示字符串 `s[0]` 到 `s[i-1]` 的哈希值，即
    $$hash[i] = (s[0] \cdot p^{i-1} + s[1] \cdot p^{i-2} + \ldots + s[i-1] \cdot p^0) \mod m$$
- 子串 `s[l..r]` 的哈希值可以通过以下公式计算（注意索引）：
    $$hash(s[l..r]) = (hash[r+1] - hash[l] \cdot p^{r-l+1}) \mod m$$

- c++ 示例
```cpp
const long long P = 23;             // 基数
const long long MOD = 1e9 + 7;      // 大模数

long long ksm(long long a, long long n, long long mod) { // 快速幂
    long long res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

vector<long long> precompute_hash(const string &s) {
    int n = s.size();
    vector<long long> hash(n + 1, 0);   // h[i] 表示 s[0..i-1] 的哈希值
    for (int i = 0; i < n; i++) {
        hash[i + 1] = (hash[i] * P + s[i]) % MOD;  // 前缀哈希
    }
    return hash;
}

long long substring_hash(const vector<long long> &hash, int l, int r) {
    long long h = (hash[r + 1] - hash[l] * ksm(P, r - l + 1, MOD) % MOD + MOD) % MOD;
    return h;
}
```


### 1.2 Manacher

- [Manacher](https://oi-wiki.org/string/manacher/) 算法用于求解字符串中的最长回文子串。

- c++示例
```cpp
// 返回字符串 s 的最长回文子串的长度（不包含 #）
int manacher(const string &s) {
    vector<char> t;
    // s = s + '#'+ c 较慢
    for (char c : s) {
        t.push_back('#');
        t.push_back(c);
    }
    t.push_back('#');
    int n = t.size();
    vector<int> p(n, 0);
    int mx = 0, id = 0;
    for (int i = 0; i < n; i++) {
        if (i < mx) p[i] = min(p[2 * id - i], mx - i);
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && t[i + p[i] + 1] == t[i - p[i] - 1]) p[i]++;
        if (i + p[i] > mx) {
            mx = i + p[i];
            id = i;
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, p[i]);
    }
    return ans;
}
```

- 最长回文后缀
```cpp
// 返回字符串 s 的最长回文后缀的长度，找前缀就 reverse 一下（不包含 #）
int manacher_suffix(const string &s) {
    vector<char> t;
    for (char c : s) {
        t.push_back('#');
        t.push_back(c);
    }
    t.push_back('#');
    int n = t.size(), ans = 0;
    vector<int> p(n, 0);
    int mx = 0, id = 0;
    for (int i = 0; i < n; i++) {
        if (i < mx) p[i] = min(p[2 * id - i], mx - i);
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && t[i + p[i] + 1] == t[i - p[i] - 1]) p[i]++;
        if (i + p[i] > mx) {
            mx = i + p[i];
            id = i;
        }
        if (i + p[i] == n - 1) {
            ans = max(ans, p[i]);
        }
    }
    return ans;
}
```

### 1.3 朴素的字符串匹配（Brute Force, BF）
- c++示例
```cpp
// 返回第一个匹配的位置，不匹配则返回 -1，时间复杂度 O(nm)
int bf(const string &s, const string &p) {
    if (p.empty()) return -1;   //
    int i = 0, j = 0;
    for (i = 0; i + p.size() <= s.size(); i++, j = i) {
        while (j < p.size() && s[i + j] == p[j]) j++;
        if (j == p.size()) return i;
    }
    return -1;
}
```

### 1.4 KMP 算法
- [KMP](https://oi-wiki.org/string/kmp/) 算法用于字符串匹配，核心是前缀函数（或称为失配函数）。

#### 1.4.1 前缀函数
- 前缀函数 `pi[i]` 表示字符串 `s[0..i]` 的最长相等前后缀的长度（真前后缀）。
- 用数学公式表示如下：
    $$\pi[i] = \max\{k \mid s[0..k-1] = s[i-k+1..i]\}$$

- 前缀函数的计算可以通过动态规划实现，时间复杂度为 $O(n)$。
- c++ 示例
```cpp
vector<int> prefix_function(const string &s) {
    int n = s.size();
    vector<int> pi(n, 0);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[j] == s[i]) j++;  // 不成立时 j = 0，最长公共前后缀为 0
        pi[i] = j;
    }
    return pi;
}
```

#### 1.4.2 KMP 匹配
- KMP 匹配算法利用前缀函数来避免重复比较，时间复杂度为 $O(n + m)$。
- c++ 示例
```cpp
// 返回第一个匹配的位置，不匹配则返回 -1
int kmp(const string &s, const string &p) {
    if (p.empty()) return -1;   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) return i - m + 1; // 完全匹配，返回起始位置
    }
    return -1; // 没有匹配
}

// 返回所有匹配的位置
vector<int> kmp_all(const string &s, const string &p) {
    if (p.empty()) return {};   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    vector<int> result;
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) {
            result.push_back(i - m + 1); // 完全匹配，记录起始位置
            j = pi[j - 1]; // 准备寻找下一个匹配
        }
    }
    return result; // 返回所有匹配的位置
}

// 返回所有匹配的位置（不重叠）
vector<int> kmp_non_overlap(const string &s, const string &p) {
    if (p.empty()) return {};   // 空串匹配
    int n = s.size(), m = p.size();
    vector<int> pi = prefix_function(p);
    vector<int> result;
    int j = 0;  // p 的指针
    for (int i = 0; i < n; i++) {
        while (j > 0 && s[i] != p[j]) j = pi[j - 1]; // 不匹配，缩小范围
        if (s[i] == p[j]) j++;  // 匹配成功，移动 p 的指针
        if (j == m) {
            result.push_back(i - m + 1); // 完全匹配，记录起始位置
            j = 0; // 重置 j，避免重叠
        }
    }
    return result; // 返回所有匹配的位置
}
```

### 1.5 Z 函数（扩展 KMP）

- [Z 函数](https://oi-wiki.org/string/z-func/) 是一个字符串处理算法，用于快速计算字符串的匹配信息。

#### 1.5.1 一些约定
约定：字符串下标从 0 开始。


#### 1.5.2 Z 函数定义
- 对于长度为 n 的字符串 `s`，Z 函数 `z[i]` 表示 `s` 与 `s[i, n-1]` 的最长公共前缀长度。特别地，`z[0]` 通常定义为 0。
- 形式化定义为：
    $$z[i] = \max\{k \mid s[0..k-1] = s[i..i+k-1]\}$$
- 国外一般将计算 z 数组的算法称为 Z-algorithm，国内也成为扩展 KMP 算法。

#### 1.5.3 样例解释

- $z[aaaaa] = [0, 4, 3, 2, 1]$
- 解释：
    - `z[0]` = 0，通常约定如此，因为没有意义比较字符串与自身。
    - `z[1]` = 4，因为 `s[0, 4]` 与 `s[1, 4]` 的最长公共前缀是 `aaaa`，长度为 4。
    - `z[2]` = 3，因为 `s[0, 4]` 与 `s[2, 4]` 的最长公共前缀是 `aaa`，长度为 3。
    - `z[3]` = 2，因为 `s[0, 4]` 与 `s[3, 4]` 的最长公共前缀是 `aa`，长度为 2。
    - `z[4]` = 1，因为 `s[0, 4]` 与 `s[4, 4]` 的最长公共前缀是 `a`，长度为 1。
- $z[aabab] = [0, 1, 0, 1, 0]$
- 解释：
    - `z[0]` = 0，通常约定如此。
    - `z[1]` = 1，因为 `s[0, 4]` 与 `s[1, 4]` 的最长公共前缀是 `a`，长度为 1。
    - `z[2]` = 0，因为 `s[0, 4]` 与 `s[2, 4]` 没有公共前缀。
    - `z[3]` = 1，因为 `s[0, 4]` 与 `s[3, 4]` 的最长公共前缀是 `a`，长度为 1。
    - `z[4]` = 0，因为 `s[0, 4]` 与 `s[4, 4]` 没有公共前缀。
- $z[ababa] = [0, 0, 3, 0, 1]$

#### 1.5.4 朴素算法
- 朴素算法的时间复杂度为 $O(n^2)$，对于每个位置 $i$，直接比较 `s[0..n-1]` 和 `s[i..n-1]` 的最长公共前缀。
- c++ 示例
```cpp
vector<int> z_function_naive(const string &s) {
    int n = s.size();
    vector<int> z(n, 0);
    for (int i = 1; i < n; i++) {
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
    }
    return z;
}
```

#### 1.5.5 线性算法
- 借助之前的计算结果，可以加速计算 Z 函数，使用时间复杂度降为 $O(n)$。
- 对于 i，称区间`[i, i + z[i] - 1]`是 i 的匹配段，也可以叫做 `Z-box`。
- 在计算过程中，我们维护一个右端点最靠右的匹配段，记作`[l, r]`，初始时为`[0, 0]`。
- 在计算 z[i] 时：
    1. 如果 i <= r（即 i 在前面的某个匹配段内）：
        1. 若 `z[i - l] < r - i + 1`，则 `z[i] = z[i - l]`。
        2. 否则，z[i] = r - i + 1，然后枚举下一个字符拓展 z[i]。
    1. 如果 i > r，直接按照朴素算法计算 z[i]。
- 更新`[l, r]`。
- c++ 示例
```cpp
vector<int> z_function(const string &s) {
    int n = s.size();
    vector<int> z(n, 0);
    int l = 0, r = 0; // 匹配段的左右端点
    for (int i = 1; i < n; i++) {
        if (i <= r) {
            z[i] = min(r - i + 1, z[i - l]); // 在匹配段内
        }
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {    // 尝试拓展 z[i]
            z[i]++;
        }
        if (i + z[i] - 1 > r) { // 更新匹配段
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```


### 1.6 Trie 树
- [Trie 树](https://oi-wiki.org/string/trie/) 是一种高效的字符串存储结构，常用于前缀匹配、自动补全等场景。

#### 1.6.1 Trie 树的定义
- Trie 树是一种多叉树，每个节点表示一个字符，路径从根节点到某个节点表示一个字符串。
- 每个节点包含一个 `children` 数组，表示所有可能的子节点。（可以使用哈希表或 unordered_map 来支持任意字符集）
- 每个节点还可以包含一个 `is_end` 标志，表示是否有字符串以该节点结尾。
- Trie 树的根节点通常不存储字符。

#### 1.6.2 Trie 树的典型应用
- **前缀匹配**：快速查找以某个前缀开头的字符串。
- **自动补全**：根据输入的前缀，快速找到所有可能的后缀。
- **字符串去重**：通过插入字符串到 Trie 树中，可以自动去除重复的字符串。
- **字符串统计**：可以统计某个字符串在 Trie 树中出现的次数。
- **字符串搜索**：可以快速判断某个字符串是否存在于 Trie 树中。
- **字符串最长公共前缀**：可以快速找到多个字符串的最长公共前缀。

#### 1.6.3 Trie 树的实现
- c++ 示例
```cpp
// Times of testing: 1
struct TrieNode {
    TrieNode *children[26]; // 假设只包含小写字母
    bool is_end;            // 是否为某个字符串的结尾

    TrieNode() : is_end(false) {
        fill(begin(children), end(children), nullptr);
    }
};
class Trie {
private:
    TrieNode *root;
public:
    Trie() {
        root = new TrieNode();
    }
    void insert(const string &word) {
        TrieNode *node = root;
        for (char c : word) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                node->children[index] = new TrieNode();
            }
            node = node->children[index];
        }
        node->is_end = true; // 标记字符串结尾
    }
    bool search(const string &word) {
        TrieNode *node = root;
        for (char c : word) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                return false; // 不存在
            }
            node = node->children[index];
        }
        return node->is_end; // 返回是否为字符串结尾
    }
    bool startsWith(const string &prefix) {
        TrieNode *node = root;
        for (char c : prefix) {
            int index = c - 'a'; // 假设只包含小写字母
            if (!node->children[index]) {
                return false; // 不存在前缀
            }
            node = node->children[index];
        }
        return true; // 前缀存在
    }
    void clear(TrieNode *node) {
        if (!node) return;
        for (int i = 0; i < 26; i++) {
            clear(node->children[i]);
        }
        delete node;
    }
    ~Trie() {
        clear(root); // 清理内存
    }
};
// 使用示例
int main() {
    Trie trie;
    trie.insert("hello");
    trie.insert("world");
    cout << trie.search("hello") << endl; // 输出 1
    cout << trie.search("hell") << endl;  // 输出 0
    cout << trie.startsWith("he") << endl; // 输出 1
    cout << trie.startsWith("wo") << endl; // 输出 1
    return 0;
}
```

#### 1.6.4 支持任意字符集的 Trie 树
- 如果需要支持任意字符集，可以使用哈希表或 unordered_map 来存储子节点。
- 使用 `wchar_t` 或 `char32_t` 等类型来表示 Unicode 字符。
- c++ 示例
```cpp
// Times of testing: 1
#include <iostream>
#include <string>
#include <map>
#include <vector>
using namespace std;

// Trie 节点
struct TrieNode {
    map<char32_t, TrieNode*> children; // 使用 map 存储子节点，键为 Unicode 字符
    bool is_end;                       // 是否为字符串结尾

    TrieNode() : is_end(false) {}
};

// 将 UTF-8 字符串转换为 Unicode 字符序列
vector<char32_t> utf8_to_unicode(const string& str) {
    vector<char32_t> result;
    size_t i = 0;
    while (i < str.size()) {
        char32_t codepoint = 0;
        // 0x80 = 10000000 检查最高位知否为 0
        if ((str[i] & 0x80) == 0) { // 1 字节 (ASCII)
            codepoint = str[i];
            i += 1;
        } else if ((str[i] & 0xE0) == 0xC0) { // 2 字节
            codepoint = ((str[i] & 0x1F) << 6) | (str[i + 1] & 0x3F);
            i += 2;
        } else if ((str[i] & 0xF0) == 0xE0) { // 3 字节（中文常用）
            codepoint = ((str[i] & 0x0F) << 12) | ((str[i + 1] & 0x3F) << 6) | (str[i + 2] & 0x3F);
            i += 3;
        } else if ((str[i] & 0xF8) == 0xF0) { // 4 字节
            codepoint = ((str[i] & 0x07) << 18) | ((str[i + 1] & 0x3F) << 12) |
                        ((str[i + 2] & 0x3F) << 6) | (str[i + 3] & 0x3F);
            i += 4;
        }
        result.push_back(codepoint);
    }
    return result;
}

// Trie 类
class Trie {
private:
    TrieNode* root;

    // 递归清理内存
    void clear(TrieNode* node) {
        if (!node) return;
        for (auto& child : node->children) {
            clear(child.second);
        }
        delete node;
    }

public:
    Trie() {
        root = new TrieNode();
    }

    // 插入字符串
    void insert(const string& word) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(word);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        node->is_end = true;
    }

    // 查找字符串
    bool search(const string& word) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(word);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        return node->is_end;
    }

    // 查找前缀
    bool startsWith(const string& prefix) {
        TrieNode* node = root;
        vector<char32_t> chars = utf8_to_unicode(prefix);
        for (char32_t c : chars) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        return true;
    }

    // 析构函数
    ~Trie() {
        clear(root);
    }
};

// 使用示例
int main() {
    Trie trie;
    trie.insert("你好");
    trie.insert("世界");
    cout << trie.search("你好") << endl;    // 输出 1
    cout << trie.search("你") << endl;      // 输出 0
    cout << trie.startsWith("世") << endl;  // 输出 1
    cout << trie.startsWith("你好") << endl; // 输出 1
    return 0;
}
```

#### 1.6.5 Trie 树a
- 下面是一个简化的 Trie 树实现，支持插入、查找和前缀匹配。
```cpp
// Times of testing: 2
// 假设只包含小写字母
const int N = 1e6 + 5;
int trie[N][26];    // Trie 树
int cnt[N];         // 记录每个节点的字符串数量
int pass[N];        // 每个节点被经过的次数（前缀匹配）
int idx = 0;        // 当前已使用的节点的索引

void insert(const string &s) {
    int node = 0; // 从根节点开始
    if (s.empty()) return; // 空字符串不插入
    pass[0]++; // 根节点被经过一次
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) {
            trie[node][index] = ++idx; // 创建新节点
        }
        node = trie[node][index]; // 移动到子节点
        pass[node]++; // 更新前缀匹配次数
    }
    cnt[node]++; // 更新字符串数量
}

bool search(const string &s) {
    int node = 0; // 从根节点开始
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) return false; // 如果子节点不存在，返回 false
        node = trie[node][index];
    }
    return cnt[node] > 0;
}

bool remove(const string &s) {
    int node = 0;
    stack<int> stk; // 记录路径上的节点
    stk.push(node);
    for (char c : s) {
        int index = c - 'a';
        if (!trie[node][index]) return false; // 字符串不存在
        node = trie[node][index];
        stk.push(node);
    }
    if (cnt[node] == 0) return false; // 字符串不存在
    cnt[node]--; // 减少字符串计数
    while (!stk.empty()) {
        pass[stk.top()]--; // 更新前缀计数
        stk.pop();
    }
    return true;
}
```

### 1.7 AC自动机
- [AC自动机](https://oi-wiki.org/string/ac-automaton/)
- AC 自动机是一种高效的字符串匹配算法，常用于多模式匹配。
- 它结合了 Trie 树和 KMP 算法的思想，能够在 O(n + m) 的时间复杂度内处理多个模式串的匹配。

#### 1.7.1 失败指针（Fail Pointer）
- 在 Trie 树的基础上，AC 自动机为每个节点添加一个失败指针（Fail Pointer），用于在匹配失败时快速跳转到下一个可能的匹配位置。
- 失败指针指向当前节点的最长后缀匹配节点。
- 失败指针用于在匹配过程中，当当前字符不匹配时，可以通过失败指针快速找到下一个可能的匹配位置，而不需要回溯到根节点。

#### 1.7.2 构建 AC 自动机
##### 1.7.2.1 构建 Trie 树
首先将所有模式串插入到 Trie 树中。

##### 1.7.2.1 构建失败指针
使用 BFS 遍历 Trie 树，构建失败指针。
```c++
void build_fail() {
    queue<int> q;
    for (int i = 0; i < M; i++) {
        if (t[0].son[i]) {
            t[t[0].son[i]].fail = 0;
            q.push(t[0].son[i]);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // 可在此记录拓扑排序
        for (int i = 0; i < M; i++) {
            if (t[u].son[i]) {
                int v = t[u].son[i];
                t[v].fail = t[t[u].fail].son[i];
                // t[v].cnt += t[t[v].fail].cnt;
                q.push(v);
            }
            else t[u].son[i] = t[t[u].fail].son[i];
        }
    }
}
```

#### 1.7.3 计算多个模式串在文本中的出现次数（c++ 示例）
```cpp
/*
 * Source of the problem: Unknow
 * File: B - AC 自动机.cpp
 * File Created: Saturday, 2025-07-19 13:41:17
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 */
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int N = 1e6 + 5;
const int M = 26;

struct Node {
    int son[M], fail;
    int in_degree; // 入度
    int cnt; // 匹配次数
    vector<int> ids; // 模式串的 ID
    Node() : fail(0), cnt(0), in_degree(0) {
        fill(son, son + M, 0);
    }
};

int idx = 0;
int ans[N];
Node trie[N];

// 插入字符串到 AC 自动机
void insert(const string &s, int id) {
    int p = 0;
    for (char c : s) {
        int u = c - 'a';
        if (!trie[p].son[u]) {
            trie[p].son[u] = ++idx;
        }
        p = trie[p].son[u];
    }
    trie[p].ids.push_back(id); // 记录该节点的模式串 ID
}

// 构建 AC 自动机的失败指针
void build() {
    queue<int> q;
    for (int i = 0; i < M; i++) {
        if (trie[0].son[i]) {
            trie[trie[0].son[i]].fail = 0;
            q.push(trie[0].son[i]);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int i = 0; i < M; i++) {
            if (trie[u].son[i]) {
                int v = trie[u].son[i];
                trie[v].fail = trie[trie[u].fail].son[i];
                q.push(v);
                // 更新入度
                trie[trie[v].fail].in_degree++;
            }
            else {
                trie[u].son[i] = trie[trie[u].fail].son[i];
            }
        }
    }
}

void query(const string &s) {
    int p = 0;
    for (char c : s) {
        int u = c - 'a';
        p = trie[p].son[u];
        trie[p].cnt++; // 统计匹配次数
    }
}

void propagate() {
    queue<int> q;
    for (int i = 0; i <= idx; i++) {
        if (trie[i].in_degree == 0) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (auto id : trie[u].ids) {
            ans[id] += trie[u].cnt; // 累加匹配次数
        }
        int v = trie[u].fail;
        if (v != 0) {
            trie[v].cnt += trie[u].cnt; // 将当前节点的匹配次数传递给失败指针
            trie[v].in_degree--; // 减少入度
            if (trie[v].in_degree == 0) {
                q.push(v); // 如果入度为 0，加入队列
            }
        }
    }
}

int main() {
    int n;
    string s, t;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s;
        insert(s, i + 1);
    }
    build();
    cin >> t;
    query(t);
    propagate();

    for (int i = 1; i <= n; i++) {
        cout << ans[i] << endl;
    }

    return 0;
}
```



### 1.8 后缀数组（Suffix Array，SA）
- [后缀数组](https://oi-wiki.org/string/sa/) 是一种高效的字符串处理数据结构，用于解决字符串的各种问题，如子串查找、最长公共前缀等。

#### 1.8.1 一些约定
- 字符串下标从 $1$ 开始
- 字符串 $s$ 的大小为 $n$


#### 1.8.2 后缀数组的应用

1. **子串查找**：
    - 后缀数组通过将字符串的所有后缀按字典序排序，可以利用二分查找快速定位某个子串是否存在于原字符串中。时间复杂度为 $O(|P| + log |S|)$，其中 $|P|$ 为模式串长度，$|S|$ 为原字符串长度（在利用 LCP 优化的情况下）。朴素实现的时间复杂度为 $O(|P| * log |S|)$，但通过 `height` 数组等优化可显著降低比较开销。
    - 应用场景：字符串匹配、模式查询（如正则表达式引擎）。


2. **最长公共前缀（LCP）查询**：
    - 结合 `height` 数组，后缀数组可以高效计算任意两个后缀的最长公共前缀。利用 RMQ（Range Minimum Query）数据结构，LCP 查询时间复杂度可优化至 O(1)。
    - 应用场景：比较两个子串的相似性、DNA 序列分析。


1. **最长重复子串**：
    - 通过 `height` 数组，找到最大值即可得到字符串中最长的重复子串（即 `height[i]` 的最大值对应的子串）。
    - 应用场景：文本压缩、数据去重。


1. **最长回文子串**：
    - 通过构造原字符串和其逆序字符串的拼接，并利用后缀数组和 LCP，可以快速找到最长的回文子串。
    - 应用场景：回文检测、生物信息学。


1. **字符串统计**：
    - 后缀数组可用于统计字符串中不同子串的个数，通过计算 `height` 数组的差值，得到唯一子串的数量，时间复杂度为 O(n)。
    - 应用场景：文本分析、搜索引擎优化。

1. **最长公共子串**：
    - 后缀数组可以计算两个字符串的最长公共子串，通过构造两个字符串的拼接后缀数组，并利用 `height` 数组找到最大值。
    - 应用场景：DNA 序列比对、版本控制系统中的文件比较。


1. **其他应用**：


#### 1.8.3 sa、rank、height 数组简介
- **后缀数组（SA）**：
  - **定义**：后缀数组 `sa` 是一个一维数组，存储字符串所有后缀按字典序排序后的起始位置。`sa[i]` 表示排在第 `i` 位的后缀的起始下标。
  - **作用**：通过 `sa` 数组，可以快速访问按字典序排列的后缀，方便解决子串比较、查找等问题。

- **rank 数组**：
  - **定义**：`rank` 数组记录每个后缀在字典序中的排名。`rank[i]` 表示从位置 `i` 开始的后缀在所有后缀中的排名，满足 `sa[rank[i]] = i`。
  - **作用**：`rank` 数组是 `sa` 数组的逆映射，用于快速查询某个后缀的字典序位置。


- **height 数组（LCP 数组）**：
  - **定义**：`height` 数组记录相邻两个后缀在字典序排序中的最长公共前缀（LCP，Longest Common Prefix）。`height[i]` 表示 `sa[i-1]` 和 `sa[i]` 对应后缀的最长公共前缀长度（`height[0]` 通常定义为 0）。
  - **作用**：`height` 数组用于高效计算任意两个后缀的 LCP，广泛应用于字符串匹配、重复子串等问题。


#### 1.8.4 倍增法计算后缀数组 O(n log n)
- 倍增法是一种高效计算后缀数组的算法，时间复杂度为 $O(n \log n)$。
- 该方法通过对后缀进行排序，逐步增加比较长度，直到所有后缀都被正确排序。
- 具体步骤如下：
  1. **初始化**：将所有后缀的长度初始化为 1，使用 `rank` 数组记录每个后缀的排名。
  2. **排序**：使用计数排序或基数排序对后缀进行排序，比较长度为 $2^k$ 的后缀。
  3. **倍增**：逐步增加比较长度，直到达到字符串长度。


#### 1.8.5 计算 height 数组
- `height` 数组可以通过后缀数组和 `rank` 数组计算得到，时间复杂度为 $O(n)$。
> 引理：$height[rank[i]] >= height[rank[i - 1]] - 1$，即相邻后缀的 LCP 长度不会小于前一个后缀的 LCP 长度减一。
- 根据引理我们有下面的计算方法：
  1. 初始化 `height` 数组，长度为 $n + 1$。
  2. 使用 `rank` 数组记录每个后缀在后缀数组中的位置。
  3. 遍历后缀数组，计算相邻后缀的 LCP 长度，并更新 `height` 数组。


#### 1.8.6 c++示例代码
```cpp
// Times of testing: 2
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e6 + 5;

int n, m;
string s;   // 假设只包含 ASCII 码
int sa[N], rk[N<<1], oldrk[N<<1], id[N], cnt[N], height[N];

int main() {
    cin >> s;
    n = s.size();
    s = 'a' + s;    // 索引从 1 开始
    m = 127;    // 最初的值域为 ASCII 码字符集大小
    for (int i = 1; i <= n; i++) cnt[rk[i] = s[i]]++;
    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;
    // rk[i]: 字符 s[i] 的排名
    // cnt[rk[i]]: 小于等于 s[i] 的数量，因此 sa[cnt[rk[i]]] = i
    // cnt[rk[i]]-- 确保下一个相同关键字或更小的后缀放在前一个位置
    memcpy(oldrk + 1, rk + 1, n * sizeof(int));

    for (int p = 0, i = 1; i <= n; i++) {
        if (oldrk[sa[i]] == oldrk[sa[i - 1]]) rk[sa[i]] = p;    // 旧排名相同，新排名也相同
        else rk[sa[i]] = ++p;
    }

    int i, p = 0, k;
    for (int w = 1; w < n; w <<= 1, m = p) {    // m = p: 值域优化
        // 第二关键字计数排序的优化
        int cur = 0;
        for (i = n - w + 1; i <= n; i++) id[++cur] = i; // 第二关键字为 0，放到前面
        for (i = 1; i <= n; i++) if (sa[i] > w) id[++cur] = sa[i] - w;
            

        // 对第一关键字 id[i] 进行计数排序
        memset(cnt, 0, (m + 1) * sizeof(int));
        for (i = 1; i <= n; i++) cnt[rk[id[i]]]++;
        for (i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
        for (i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];

        memcpy(oldrk + 1, rk + 1, n * sizeof(int));
        for (i = 1, p = 0; i <= n; i++) {
            if (oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) rk[sa[i]] = p;
            else rk[sa[i]] = ++p;
        }
        if (p == n) break;  // 排名计算完毕，sa 可能要重新计算
    }
    // 计算 height 数组
    for (i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 0) continue;
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        height[rk[i]] = k;
    }

    return 0;
}
```

#### 1.8.7 O(n(logn)^2) 实现
```cpp
// Times of testing: 1
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e6 + 5;

int n;
string s;
int sa[N], rk[N<<1], oldrk[N<<1], height[N];

int main() {
    int i, p, k;
    cin >> s;
    n = s.size();
    s = 'a' + s;    // 索引从 1 开始
    for (i = 1; i <= n; i++) {
        sa[i] = i;
        rk[i] = s[i];
    }
    for (int w = 1; w < n; w <<= 1) {
        sort(sa + 1, sa + n + 1, [w] (int x, int y) {
            return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
        });
        // 更新排名
        for (i = 1; i <= n; i++) oldrk[i] = rk[i];
        for (p = 1, i = 1; i <= n; i++) {
            if (oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
                rk[sa[i]] = p;  // 排名相同
            }
            else rk[sa[i]] = ++p;
        }
        // if (p == n) break;  // 计算完成
    }
    // 根据 sa 计算 rk
    for (i = 1; i <= n; i++) rk[sa[i]] = i;
    // 计算 height
    for (i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 0) continue;
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        height[rk[i]] = k;
    }

    for (i = 1; i <= n; i++) cout << sa[i] << ' ';

    return 0;
}
```


## 2 数论

数论是数学的一个分支，主要研究整数及其性质。数论涉及的内容非常广泛，包括但不限于素数、整除性、同余、数的分解、逆元、模运算等。数论在密码学、计算机科学和其他数学分支中有着重要的应用。


### 2.1 素数

#### 2.1.1 定义
素数也叫质数，是大于 1 的自然数，且只能被 1 和它本身整除。例如 2、3、5、7、11 都是素数。

#### 2.1.2 判断素数
判断一个数是否为素数可以使用 **试除法**。具体步骤如下：
1. 如果数小于 2，则不是素数。
2. 对于大于等于 2 的数 n，检查从 2 到 $\sqrt{n}$ 的所有整数是否能整除 n。
3. 如果存在一个整数能整除 n，则 n 不是素数；否则， n 是素数。
- c++示例，时间复杂度为 $O(\sqrt{n})$：
```cpp
bool isPrime(int n) {
    if (n < 2 || !(n & 1) && n != 2) return n == 2; // 2 是素数，其他偶数不是素数
    for (int i = 2; i * i <= n; i++) {  // 注意不要溢出
        if (n % i == 0) return false;
    }
    return true;
}
```

#### 2.1.3 埃拉托斯筛法（Sieve of Eratosthenes，埃氏筛，时间复杂度 $O(n \log \log n)$）
埃拉托斯筛法是一种高效的素数筛选算法，用于找出小于等于某个数 n 的所有素数。其基本思想是从 2 开始，依次将每个素数的倍数标记为非素数。
- c++示例：
```cpp
int n = 100; // 找出小于等于 n 的所有素数
vector<bool> isPrime(n + 1, true);
isPrime[0] = isPrime[1] = false;
for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) { // 如果 i 是素数
        for (int j = i * i; j <= n; j += i) {   // j = i * 2 效率略低，注意不要溢出
            isPrime[j] = false;
        }
    }
}
```

#### 2.1.4 欧拉筛法（Euler's Sieve，时间复杂度 $O(n)$）
欧拉筛也叫线性筛，是一种改进的素数筛选算法。它的核心思想是让每一个合数被最小的素数因子筛掉，从而避免了重复筛选。
- 合数 = 最小素数 * 自然数
- c++示例：
```cpp
int n = 100; // 找出小于等于 n 的所有素数
vector<bool> isPrime(n + 1, true); // true 表示素数，false 表示非素数
vector<int> primes; // 存储素数
isPrime[0] = isPrime[1] = false;
for (int i = 2; i <= n; i++) {
    if (isPrime[i]) { // 如果 i 是素数
        primes.push_back(i);
    }
    for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
        isPrime[i * primes[j]] = false; // 标记合数
        if (i % primes[j] == 0) break; // 确保每个合数只被最小素数因子筛掉
    }
}
```

### 2.2 最大公约数（greatest common divisor，GCD）

### 2.3 最小公倍数（least common multiple，LCM）

### 2.4 拓展欧几里得（Extended Euclidean Algorithm）

已知 $a$，$b$，拓展欧几里得可以求得 $gcd(a, b)$和 $ax + by = gcd(a, b)$的一组整数解 $x$ 与 $y$。推导过程如下：

$$gcd(a, b) = gcd(b, a \bmod b)$$

如果现在存在 $x_2$，$y_2$ 使得

$$bx_2 + (a \bmod b)y_2 = gcd(b, a \bmod b)$$

那么会有

$$ax + by = bx_2 + (a \bmod b)y_2 $$ $$\Downarrow$$

$$ax + by = bx_2 + (a - b \times (a / b))y_2$$

$$\Downarrow$$

$$ax + by = bx_2 + ay_2 - b \times (a / b)y_2$$

$$\Downarrow$$

$$ ax + by = ay_2 + b(x_2 - (a / b)y_2)$$

此时得到一组解

$$\left\{\begin{aligned}x&=y_2\\y&=x_2 - (a / b)y_2\end{aligned}\right.$$

可以采取**递归**的方法，重复这个过程直至**普通欧几里得算法**的**递归基**即$$b = 0$$

此时易知使得$ax_n + by_n = gcd(a, b)$成立，即
$$\left\{\begin{aligned}x_n&=1\\y_n&=0\end{aligned}\right.$$

在回溯过程中可计算得到 $x$，$y$

#### c++代码实现

```c++
// Times of testing: 2
using ll = long long;
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { // 递归终止
        x = 1;
        y = 0;
        return a;
    }
    ll gcd = exgcd(b, a % b, x, y);
    ll tmp = x;
    x = y;  // x = y_2
    y = tmp - (a / b) * y;  // y = x_2 - (a / b) * y_2
    return gcd;
}
```

### 2.5 逆元（Modular Inverse）
#### 2.5.1 定义

如果 $ab \equiv 1 \pmod{p}$，则 $a$ 和 $b$ 在模 $p$ 意义下互为**乘法逆元**。

#### 2.5.2 逆元存在的条件

$gcd(a, p) = 1$

#### 2.5.3 逆元的作用

除法取余: $\frac{a}{b} \bmod p = a \times inv(b) \bmod p$。其中$inv(b)$为 $b$ 在模 $p$ 意义下的乘法逆元。

#### 2.5.4 逆元的计算方法

##### 5.4.1 拓展欧几里得（通用）

$$
ab \equiv 1 \pmod p \Leftrightarrow ab = 1 + kp \Leftrightarrow ab - kp = 1
$$

把 $b$ 换成 $x$，$-k$ 换成 $y$，得到

$$
ax + py = 1
$$


解得的正整数 $x$ 即为 $a$ 在模 $p$ 下的逆元。

c++参考代码

```c++
// Times of testing: 1
using ll = long long;
// 拓展欧几里得
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll res = exgcd(b, a % b, x, y);
    ll tmp = x;
    x = y;
    y = tmp - (a / b) * y;
    return res;
}
ll inv(ll a, ll p) {
    ll x, y;
    ll gcd_res = exgcd(a, p, x, y);
    if (gcd_res != 1) return -1;    // 没有逆元
    return ((x % p) + p) % p;
}
```

##### 5.4.2 费马小定理（p 为质数，常用）

- 费马小定理：

> 如果 $p$ 是一个质数，$a$ 是一个整数且不能被 $p$ 整除（即 $a$ 与 $p$ 互质），那么有 $a^{p-1} \equiv 1 \pmod{p}$。换句话说，当一个整数 $a$ 与质数 $p$ 互质时，$a$ 的p-1次方除以 $p$ 的余数是1

由费马小定理可得 $a \times a^{p-2} \equiv 1 \pmod{p}$,因此 $a$ 在模 $p$ 意义下的一个逆元是 $a^{p-2}$，用**快速幂**可快速计算出。

c++参考代码

```c++
using ll = long long;
ll quick_pow(ll a, ll n, ll m) {   // 计算 (a ^ n) mod m
    ll res = 1;
    while (n) {
        if (n & 1) res = (res * a) % m;
        a = (a * a) % m;
        n >>= 1;
    }
    return res;
}
ll inv(ll a, ll p) { // 计算 a 在模 p 意义下的逆元，p 为素数
    return quick_pow(a, p - 2, p);
}
```

##### 5.4.3 线性递推、记忆化搜索（p 为素数）

设 $p = aq + r$，其中 $r = p \bmod a$，则 $q = \lfloor \frac{p}{a} \rfloor$

在模 $p$ 意义下，有 

$$
aq + r \equiv 0 \pmod{p}
$$


$$
\Downarrow
$$

$$
a = -r \times inv(q) \pmod{p}
$$

$$
\Downarrow
$$

$$
inv(a) = -q \times inv(r) \pmod{p}
$$

$$
\Downarrow
$$

$$
inv(a) = -\lfloor \frac{p}{a} \rfloor \times inv(p \bmod a) \pmod{p}
$$

线性递推 c++ 参考代码
```c++
// Times of testing: 0
// n 可以大于 p
int inv[N], p;  // inv[i]: i 在模 p 意义下的逆元，p 要为素数
void inverse_element_init(int n, int p) {
    for (int i = 0; i <= n; i++) inv[i] = 0;
    inv[1] = 1;

    for (int i = 2; i <= min(n, p-1); i++) {    // 计算 i < p 的逆元
        inv[i] = (((-p / i * inv[p % i]) % p) + p) % p;
    }

    for (int i = p; i <= n; i++) {  // 对于 i >= p 的情况，使用同余性质
        int r = i % p;
        inv[i] = (r == 0) ? 0 : inv[r]; // 直接复用 r 的逆元
    }
}
```

#### 2.5.5 阶乘的逆元

在模 $p$ 意义下，$a$ 的逆元和 $a \bmod p$ 的逆元是相等的，这是因为模 $p$ 的逆元是基于同余关系的，而同余关系满足以下性质：

* 如果 $a \equiv b \pmod p$，则 $a$ 和 $b$ 在模 $p$ 意义下的逆元是相等的。

显然，$a \bmod p \equiv (a \bmod p) \bmod p$，因此 $a$ 和 $a \bmod p$ 在模 $p$ 意义下的逆元是相等的。因此在模 $p$ 意义下 

$$
inv(n!) \equiv inv(n! \bmod p) \pmod p
$$


##### 5.5.1 阶乘逆元线性递推（条件：$p$ 为素数且 $n < p$）

$$
n! \times inv(n!) \equiv 1 \pmod p
$$

$$
\Downarrow
$$

$$
(n-1)! \times n \times inv(n!) \equiv 1 \pmod p
$$

由此得到递推公式：$inv((n-1)!) \equiv n \times inv(n!) \bmod p \pmod p$


### 2.6 线性同余方程
#### 2.6.1 定义
线性同余方程的形式为 $ax \equiv b \pmod{m}$，其中 $a$、$b$、$m$ 是已知整数，$x$ 是未知数，需要从区间 [0, m - 1] 中求解 $x$ 的值。

#### 2.6.2 解的存在性
线性同余方程 $ax \equiv b \pmod{m}$ 有解的充分必要条件是 $gcd(a, m)$ 能整除 $b$。如果 $gcd(a, m) = g$，则方程有 $g$ 个解。

#### 2.6.3 用逆元求解

如果 $gcd(a, m) = 1$，此时方程有**唯一解**，可以通过求 $a$ 的逆元来解方程。$$x \equiv a^{-1}b \pmod{m}$$

#### 2.6.4 用扩展欧几里得求解

- 线性同余方程 $ax \equiv b \pmod{m}$ 可以改写为 $ax + mk = b$，其中 $x$ 和 $k$ 是未知数，该方程有整数解的充分必要条件是 $gcd(a, m)$ 能整除 $b$。先求出 $ax + mk = gcd(a, m)$ 的一组整数解 $(x_0, k_0)$，然后将其乘以 $\frac{b}{gcd(a, m)}$，得到 $a\frac{b}{gcd(a, m)}x_0 + m\frac{b}{gcd(a, m)}k_0 = b$ 的一组整数解 $(\frac{b}{gcd(a, m)}x_0, \frac{b}{gcd(a, m)}k_0)$。


- 若 $gcd(a, m) = 1$，且 $x_0$，$k_0$ 为方程 $ax + mk = b$ 的一组解，则该方程的任意解可表示为：$$x=x_0+mt$$ $$k=k_0-at$$ t 为任意整数。

- 实际问题中，往往要求出一个最小整数解，也就是一个特解$$x=(x \bmod t + t) \bmod t$$其中$$t=\frac{m}{gcd(a, m)}$$


### 2.7 中国剩余定理 (Chinese Remainder Theorem, CRT)

#### 2.7.1 定义

中国剩余定理用于求解如下形式的一元线性同余方程组（其中 $m_1,m_2,...,m_k$ 是两两互质的正整数）：
$$\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}$$

#### 2.7.2 计算过程
1. 计算所有模数的积：$M = m_1 \times m_2 \times ... \times m_k$。
2. 对于每个 $i$，计算 $M_i = \frac{M}{m_i}$。
3. 计算 $M_i$ 在模 $m_i$ 意义下的逆元 $M_i^{-1}$，即满足 $M_i \cdot M_i^{-1} \equiv 1 \pmod{m_i}$。
4. 方程组在模 $M$ 意义下唯一解为：
$$x \equiv \sum_{i=1}^{k} a_i \cdot M_i \cdot M_i^{-1} \pmod{M}$$

#### 2.7.3 c++实现
```cpp
// Times of testing: 0
long CRT(const vector<long long>& a, const vector<long long>& m) {
    int k = a.size();
    long long M = 1, res = 0;

    // 计算所有模数的积
    for (int i = 0; i < k; i++) M *= m[i];

    // 对每个模数计算 M_i 和 M_i 的逆元
    for (int i = 0; i < k; i++) {
        long long Mi = M / m[i];
        long long Mi_inv = inv(Mi, m[i]); // 使用之前定义的 inv 函数
        res = (res + a[i] * Mi * Mi_inv) % M;
    }

    return (res + M) % M; // 确保结果为非负数
}
```

#### 2.7.4 扩展中国剩余定理（模数不互质）

##### 7.4.1

设两个方程分别是 $x \equiv a_1 \pmod {m_1}、x \equiv a_2 \pmod {m_2}$，将他们转化为不定方程：$x=m_1p+a_1=m_2q+a_2$，则有$$m_1p-m_2q=a_2-a_1$$由裴蜀定理，当 $a_2-a_1$ 不能被 $gcd(m_1,m_2)$ 整除时，无解；其他情况下，可以通过 扩展欧几里得算法 解出来一组可行解 $(p, q)$；
则原来的两方程组成的模方程组的解为 $x \equiv b \pmod M$，其中 $b=m_1p+a_1, M=lcm(m_1, m_2)$
- 若有多个方程，则用上面的方法两两合并即可

##### 7.4.2 c++ 代码
```c++
// Times of testing: 1
ll ex_gcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll g = ex_gcd(b, a % b, x, y);
    ll temp = x;
    x = y;
    y = temp - a / b * y;
    return g;
}

ll lcm(ll a, ll b) {
    ll x, y;
    return a / ex_gcd(a, b, x, y) * b;
}

// 解方程：x = a1 (mod m1), x = a2 (mod m2)，无解返回 false
// 解为 x = b (mod M)
bool ex_CRT(ll a1, ll m1, ll a2, ll m2, ll &b, ll &M) {
    ll p, q;
    ll g = ex_gcd(m1, m2, p, q);
    if ((a2 - a1) % g != 0) return false;
    M = lcm(m1, m2);
    p = ((__int128) p * (a2 - a1) / g % M + M) % M; // 使用__int127 防止中间值溢出
    b = (((__int128) m1 * p + a1) % M + M) % M;

    return true;
}

// 解 x = a (mod m) 的线性同余方程组，n >= 1，无解返回 false
bool ex_CRT(vector<ll> a, vector<ll> m, ll &b, ll &M) {
    b = a[0];
    M = m[0];
    for (int i = 1; i < a.size(); i++) {
        bool res = ex_CRT(a[i], m[i], b, M, b, M);
        if (res == false) return false;
    }
    return true;
}
```



### 2.8 欧拉函数

#### 2.8.1 定义

欧拉函数 $\phi(n)$ 是一个整数函数，表示小于等于 $n$ 的正整数中与 $n$ 互质的数的个数。换句话说，$\phi(n)$ 是 $1$ 到 $n$ 中与 $n$ 互质的整数的数量。

#### 2.8.2 欧拉函数的性质

1. **基本性质**：如果 $p$ 是素数，则 $\phi(p) = p - 1$。
2. **乘法性质**：如果 $a$ 和 $b$ 互质，则 $\phi(ab) = \phi(a) \cdot \phi(b)$。
3. **质因数分解**：如果 $n$ 的质因数分解为 $p_1^{k_1} \cdot p_2^{k_2} \cdots p_m^{k_m}$，则
   $$\phi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right)$$
4. **递推性质**：如果 $n$ 是一个正整数，则 $\phi(n)$ 可以通过以下递推公式计算：
   $$\phi(n) = n \cdot \prod_{p | n} \left(1 - \frac{1}{p}\right)$$
5. 当 $n$ 为奇数时，$\phi(2n) = \phi(n)$。
6. 当 $n > 2$ 时，$\phi(n)$ 是偶数。
7. 小于 $n$ 的数中，与 $n$ 互质的数的总和为 $\frac{n \cdot \phi(n)}{2}$。
6. $n = \sum_{d | n} \phi(d)$，其中 $d$ 是 $n$ 的所有正因数。（欧拉反演）
7. 若 $n=p^k$，其中 $p$ 是素数，则 $\phi(n) = p^k - p^{k-1} = p^{k-1}(p - 1)$。

#### 2.8.3 计算欧拉函数
计算欧拉函数的常用方法是通过质因数分解。对于一个正整数 $n$，可以先找到它的所有质因数，然后使用上述性质来计算 $\phi(n)$。
- c++ 示例代码：
```cpp
// Times of testing: 3
int phi(int n) {
    int result = n; // 初始化结果为 n
    for (long long i = 2; i * i <= n; i++) {
        if (n % i == 0) { // 如果 i 是 n 的一个质因数
            while (n % i == 0) {
                n /= i; // 除去所有的 i
            }
            result -= result / i; // 使用欧拉函数的性质
        }
    }
    if (n > 1) { // 如果 n 仍然大于 1，则它是一个质数
        result -= result / n;
    }
    return result;
}
```

#### 2.8.4 线性递推
欧拉函数也可以通过线性递推来计算。对于 $n$ 的每个正整数，可以使用以下递推公式：
$$\phi(n) = n \cdot \prod_{p | n} \left(1 - \frac{1}{p}\right)$$其中 $p$ 是 $n$ 的所有质因数。
- c++ 示例代码：
```cpp
// Times of testing: 3
vector<int> euler(int n) {
    vector<int> phi(n + 1);
    for (int i = 1; i <= n; i++) {
        phi[i] = i; // 初始化
    }
    for (int i = 2; i <= n; i++) {
        if (phi[i] == i) { // 如果 i 是素数
            for (int j = i; j <= n; j += i) {
                phi[j] -= phi[j] / i; // 更新欧拉函数值
            }
        }
    }
    return phi;
}
```
- 线性筛
```cpp
// Times of testing: 2
vector<int> euler_phi(int n) {
    vector<int> phi(n + 1);
    vector<int> primes;
    vector<bool> is_composite(n + 1, false);

    // 初始化
    phi[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!is_composite[i]) {
            primes.push_back(i);
            phi[i] = i - 1;  // i 是质数
        }
        // 线性筛：用每个数的最小质因子去筛
        for (int p : primes) {
            if (i * p > n) break;
            is_composite[i * p] = true;
            if (i % p == 0) {   // p 是 i 的最小质因子，且 p^2 | (i*p)
                phi[i * p] = phi[i] * p;
                break;
            }
            phi[i * p] = phi[i] * (p - 1);  // p 不整除 i，所以 gcd(i, p) = 1
        }
    }
    return phi;
}
```

#### 8.5 欧拉定理

若 $gcd(a, m) = 1$，则 $a^{\phi(m)} \equiv 1 \pmod m$

#### 8.6 扩展欧拉定理

$$a^b \equiv \begin{cases}
a^{b \bmod \phi(m)} \pmod m， & \text gcd(a, m) = 1 \\
a^{b} \pmod m， & \text gcd(a, m) \neq 1，b < \phi(m) \\
a^{b \bmod \phi(m) + \phi(m)} \pmod m， & \text gcd(a, m) \neq 1，b \geq \phi(m)
\end{cases}$$


## 3 树

### 3.1 线段树


### 3.2 树状数组


### 3.3 树链剖分（HLD）（重链剖分）

- [树链剖分](https://oi-wiki.org/graph/hld/) 是一种将树转化为链的技巧，常用于处理树上的路径查询和修改问题。树链剖分有多种形式，如**重链剖分**和**长链剖分**，大多数情况下**树链剖分**指的就是**重链剖分**。下面只讲重链剖分。

#### 3.3.1 一些定义

- **重子节点**：在树链剖分中，重子节点是指子树中最大的子节点， 若有多个最大的子节点，可以选择任意一个。
- **轻子节点**：在树链剖分中，轻子节点是指子树中不是重子节点的子节点。
- **重边**：到达重子节点的边称为重边。
- **轻边**：到达轻子节点的边称为轻边。
- **重链**：若干条重边连接起来路径称为重链。
- **轻链**：与重链相对，轻链是指不在重链上的边。

#### 3.3.2 重链剖分的实现
- 重链剖分的实现分为两个 DFS 过程：
- 第一个 DFS 获取以下数组：
    - `size[i]`：节点 `i` 的子树大小。
    - `deep[i]`：节点 `i` 的深度。
    - `big_son[i]`：节点 `i` 的重子节点。
    - `father[i]`：节点 `i` 的父节点。
- 第二个 DFS 获取以下数组：
    - `top[i]`：节点 `i` 所在重链的顶点。
    - `dfn[i]`：节点 `i` 的 DFS 序号。

#### 3.3.3 数链剖分计算 LCA
```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 5e5 + 5;

vector<int> g[N];
int deep[N];    // 节点深度
int fa[N];      // 父节点
int siz[N];     // 子树的节点数量
int son[N];     // 重儿子
int top[N];     // top[x]: x 所在重链的链头

// 计算 deep[]、fa[]、size[]、son[]
int dfs1(int cur, int father, int d) {
    int node_cnt = 1;
    int big_son = 0, max_cnt = 0;
    deep[cur] = d;
    fa[cur] = father;
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father) continue;
        int t = dfs1(g[cur][i], cur, d + 1);
        node_cnt += t;
        if (t > max_cnt) {
            max_cnt = t;
            big_son = g[cur][i];
        }
    }
    siz[cur] = node_cnt;
    son[cur] = big_son;
    return node_cnt;
}

// 计算 top[]
void dfs2(int cur, int father, int head) {
    top[cur] = head;
    if (son[cur] != 0) dfs2(son[cur], cur, head);   // 先递归搜索重儿子，确保重链内节点 DFS 序连续
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father || g[cur][i] == son[cur]) continue;
        dfs2(g[cur][i], cur, g[cur][i]);    // 轻儿子，另一条重链的链头
    }
}

int lca(int u, int v) {
    while (top[u] != top[v]) {  // 不在同一条重链
        if (deep[top[u]] > deep[top[v]]) u = fa[top[u]];
        else v = fa[top[v]];
    }
    if (deep[u] < deep[v]) return u;
    return v;
}

int main() {
    int n, m, root, u, v;
    cin >> n >> m >> root;
    for (int i = 1; i <= n - 1; i++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(root, 0, 1);
    dfs2(root, 0, root);
    for (int i = 1; i <= m; i++) {
        cin >> u >> v;
        cout << lca(u, v) << '\n';
    }

    return 0;
}
```
    
#### 3.3.4 树链剖分+线段树示例
```cpp
/*
 * Source of the problem: Unknow
 * File: 树链剖分.cpp
 * File Created: Thursday, 2025-07-03 21:49:25
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 */
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

#define int long long

struct node {
    int v, tag;
    node(int v1 = 0, int tag1 = 0): v(v1), tag(tag1) {}
};

const int N = 2e5 + 5;
ll p;

int n;
int idx = 0;    // DFS 序号
vector<int> g[N];
int dfn[N];
int siz[N], fa[N], deep[N], top[N], son[N], a[N], b[N];
node tree[N<<2];

void push_up(int rt) {
    tree[rt].v = (tree[rt<<1].v + tree[rt<<1|1].v) % p;
}

void build(int rt, int l, int r) {
    if (l == r) {
        tree[rt].v = a[l];
        tree[rt].tag = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build(rt<<1, l, mid);
    build(rt<<1|1, mid + 1, r);
    push_up(rt);
}

void push_down(int rt, int l, int r) {
    if (l == r) return; // 叶节点不用管
    int mid = (l + r) >> 1;
    int ln = (mid - l + 1), rn = (r - mid);
    tree[rt<<1].v = (tree[rt<<1].v + ln * tree[rt].tag) % p;
    tree[rt<<1|1].v = (tree[rt<<1|1].v + rn * tree[rt].tag) % p;
    tree[rt<<1].tag = (tree[rt<<1].tag + tree[rt].tag) % p;
    tree[rt<<1|1].tag = (tree[rt<<1|1].tag + tree[rt].tag) % p;
    tree[rt].tag = 0;
}

// 将 [L, R] 中的值都加 x
void update(int rt, int l, int r, int L, int R, int x) {
    if (l >= L && r <= R) {
        tree[rt].v = ((r - l + 1) * x + tree[rt].v) % p;
        tree[rt].tag = (tree[rt].tag + x) % p;
        return;
    }
    int mid = (l + r) >> 1;
    push_down(rt, l, r);
    if (L <= mid) update(rt<<1, l, mid, L, R, x);
    if (R > mid) update(rt<<1|1, mid + 1, r, L, R, x);
    push_up(rt);
}

int query(int rt, int l, int r, int L, int R) {
    if (l >= L && r <= R) return tree[rt].v % p;    // 忘取余了，哎
    ll res = 0, mid = (l + r) >> 1;
    push_down(rt, l, r);
    if (L <= mid) res += query(rt<<1, l, mid, L, R);
    if (R > mid) res += query(rt<<1|1, mid + 1, r, L, R);
    // cout << "res=" << res << '\n';
    return res % p;
}

void dfs1(int cur, int father) {
    fa[cur] = father;
    deep[cur] = deep[father] + 1;
    siz[cur] = 1;
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father) continue;
        dfs1(g[cur][i], cur);
        siz[cur] += siz[g[cur][i]];
        if (!son[cur] || siz[son[cur]] < siz[g[cur][i]]) son[cur] = g[cur][i];
    }
}

// 计算 top[]、dfn[]
void dfs2(int cur, int father, int head) {
    dfn[cur] = ++idx;
    top[cur] = head;
    if (son[cur]) dfs2(son[cur], cur, head);
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father || g[cur][i] == son[cur]) continue;
        dfs2(g[cur][i], cur, g[cur][i]);
    }
}

// 更新子树
void update(int root, int x) {
    update(1, 1, n, dfn[root], dfn[root] + siz[root] - 1, x);
}

// 更新路径上的节点
void update(int u, int v, int x) {
    while (top[u] != top[v]) {
        if (deep[top[u]] > deep[top[v]]) {
            update(1, 1, n, dfn[top[u]], dfn[u], x);
            u = fa[top[u]];
        }
        else {
            update(1, 1, n, dfn[top[v]], dfn[v], x);
            v = fa[top[v]];
        }
    }
    // 到达同一重链
    if (deep[u] < deep[v]) swap(u, v);
    update(1, 1, n, dfn[v], dfn[u], x);
}

// 查询子树的和
ll query(int root) {
    return query(1, 1, n, dfn[root], dfn[root] + siz[root] - 1);
}

// 查询两点路径上的节点和
ll query(int u, int v) {
    ll res = 0;
    while (top[u] != top[v]) {
        if (deep[top[u]] > deep[top[v]]) {
            res = (res + query(1, 1, n, dfn[top[u]], dfn[u])) % p;
            u = fa[top[u]];
        }
        else {
            res = (res + query(1, 1, n, dfn[top[v]], dfn[v])) % p;
            v = fa[top[v]];
        }
    }
    if (deep[u] < deep[v]) swap(u, v);
    res = (res + query(1, 1, n, dfn[v], dfn[u])) % p;
    return res;
}

signed main() {
    int m, root, opt, x, y, z, u, v;
    cin >> n >> m >> root >> p;
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n - 1; i++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(root, 0);
    dfs2(root, 0, root);
    for (int i = 1; i <= n; i++) {
        a[dfn[i]] = b[i];   // 节点 i 的新编号为 dfn[i]
    }
    build(1, 1, n);

    for (int i = 1; i <= m; i++) {  // 操作
        cin >> opt;
        if (opt == 1) {
            cin >> x >> y >> z;
            update(x, y, z);
        }
        else if (opt == 2) {
            cin >> x >> y;
            cout << query(x, y) << '\n';
        }
        else if (opt == 3) {
            cin >> x >> z;
            update(x, z);
        }
        else if (opt == 4) {
            cin >> x;
            cout << query(x) << '\n';
        }
    }

    return 0;
}
```



### 3.4 最近公共祖先

- [最近公共祖先](https://oi-wiki.org/graph/lca/)（LCA）是树上常见的查询问题，用于查询两个节点的最近公共祖先。LCA 的求解方法有多种，常用的有倍增法、tarjan 算法（离线算法）和树链剖分等。下面介绍倍增法。

```c++
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
const int K = 20; // 2^K >= N
// const int K = log2(N) + 1;
vector<int> g[N];
int fa[N][K]; // fa[i][j] 表示节点 i 的 2^j 祖先
int deep[N]; // 节点深度

// 节点编号从 1 开始
void dfs(int cur, int father) {
    fa[cur][0] = father; // 2^0 祖先
    deep[cur] = deep[father] + 1;
    for (int i = 1; i < K; i++) {
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1]; // 2^i 祖先
    }
    for (int next : g[cur]) {
        if (next != father) dfs(next, cur);
    }
}

int lca(int u, int v) {
    if (deep[u] < deep[v]) swap(u, v); // 确保 u 深度大于等于 v
    // 提升 u 到与 v 同一深度
    for (int i = K - 1; i >= 0; i--) {
        if (deep[fa[u][i]] >= deep[v]) {
            u = fa[u][i];
        }
    }
    if (u == v) return u; // 如果已经相等，直接返回
    // u, v 一起向上跳
    for (int i = K - 1; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0]; // 返回最近公共祖先
}
```

### 3.5 树的直径
- 树的直径是指树中任意两个节点之间的最长路径长度。可以通过两次 BFS 或 DFS 来求解树的直径。

- 步骤：
  1. 从任意节点开始，使用 BFS 或 DFS 找到距离最远的节点 A。
  2. 从节点 A 开始，再次使用 BFS 或 DFS 找到距离最远的节点 B，此时 A 和 B 之间的距离即为树的直径。


### 3.6 树的重心

- 树的重心是指树中一个或多个节点，使得从这些节点出发到达其他所有节点的最大距离最小。重心可以通过 DFS 来求解。

- 步骤：
  1. 对树进行 DFS，计算每个节点的子树大小。
  2. 对于每个节点，计算其作为重心时的最大子树大小。
  3. 找到使得最大子树大小最小的节点，即为重心。



## 4 计算几何

### 4.1 二维平面上点的定义
```c++
const double eps = 1e-6
struct Point {
    double x, y;
    Ponit(double x1 = 0.0, double y1 = 0.0) : x(x1), y(y1) {}
    Point operator+(const Point &p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point &p) const {
        return Point(x - p.x, y - p.y);
    }
    bool operator==(const Point &p) const {
        return fabs(x - p.x) < eps && fabs(y - p.y) < eps;
    }
    // 内积
    double dot(const Point &p) const {
        return x * p.x + y * p.y;
    }
    // 外积
    double cross(const Point &p) const {
        return x * p.y - y * p.x;
    }
}

```

### 4.2 二维平面上直线的定义
```c++
struct Line {
    double a, b, c; // ax + by + c = 0
    Line(double a1 = 0.0, double b1 = 0.0, double c1 = 0.0) : a(a1), b(b1), c(c1) {}
    Line(const Point &p1, const Point &p2) {
        a = p2.y - p1.y;
        b = p1.x - p2.x;
        c = p2.x * p1.y - p1.x * p2.y;
    }
    // 判断点是否在直线上
    bool onLine(const Point &p) const {
        return fabs(a * p.x + b * p.y + c) < eps;
    }
};
```

### 4.3 二维平面上线段的定义
```c++
struct Segment {
    Point p1, p2;
    Segment(const Point &p1, const Point &p2) : p1(p1), p2(p2) {}
    // 判断点是否在线段上
    bool onSegment(const Point &p) const {
        return onLine(p) && (p.x >= min(p1.x, p2.x) && p.x <= max(p1.x, p2.x)) &&
               (p.y >= min(p1.y, p2.y) && p.y <= max(p1.y, p2.y));
    }
    // 判断两线段是否相交
    bool intersect(const Segment &s) const {
        double d1 = (s.p2 - s.p1).cross(p1 - s.p1);
        double d2 = (s.p2 - s.p1).cross(p2 - s.p1);
        double d3 = (p2 - p1).cross(s.p1 - p1);
        double d4 = (p2 - p1).cross(s.p2 - p1);
        return (d1 * d2 < 0 && d3 * d4 < 0) || (d1 == 0 && onSegment(s.p1)) ||
               (d2 == 0 && onSegment(s.p2)) || (d3 == 0 && s.onSegment(p1)) ||
               (d4 == 0 && s.onSegment(p2));
    }
};
```

### 4.4 凸包

```c++
using ld = long double;
const ld eps = 1e-12;

struct Point {
    ld x, y;

    Point operator - (const Point &p) {
        return {x - p.x, y - p.y};
    }

    bool operator < (const Point &p) const {
        if (fabs(x - p.x) > eps) return x < p.x;
        if (fabs(y - p.y) > eps) return y < p.y;
        return false;
    }
};

ld cross(Point p1, Point p2) {
    return p1.x * p2.y - p1.y * p2.x;
}

// 计算凸包
vector<Point> convex_hull(vector<Point> p) {
    sort(p.begin(), p.end());    // x 递增，x 相等 y 递增
    // p.erase(unique(p.begin(), p.end()), p.end());    // 去重，需重载 ==
    if (p.size() <= 2) return p;    // !!! 实际可能需要去重

    vector<Point> res;
    int cnt = 0;

    // 计算下凸包
    for (int i = 0; i < p.size(); i++) {
        // < -eps 包含共线点和重复点（严格右转）
        // < eps 不包含共线点和重复点（不左转）
        // 确保与计算下凸包时一致
        while (cnt >= 2 && cross(res[cnt - 1] - res[cnt - 2], p[i] - res[cnt - 1]) < eps) {
            res.pop_back();
            cnt--;
        }
        res.push_back(p[i]);
        cnt++;
    }

    // 计算上凸包
    int lower_cnt = cnt;
    for (int i = (int)p.size() - 2; i >= 0; i--) {
        while (cnt > lower_cnt && cross(res[cnt - 1] - res[cnt - 2], p[i] - res[cnt - 1]) < eps) {
            res.pop_back();
            cnt--;
        }
        res.push_back(p[i]);
        cnt++;
    }

    res.pop_back(); // 第一个点算了两次

    return res;
}

```


## 5 组合数学

### 5.1 组合数
#### 5.1.1 定义
组合数 $C(n, m)$ 表示从 $n$ 个不同的元素中选出 $m$ 个元素的不同选择方式的数量,常用 $C_{n}^{m}$ 或 $\binom{n}{m}$ 表示。。其计算公式为：
$$C(n, m) = \frac{n!}{m!(n-m)!}$$

### 5.2 卢卡斯定理（Lucas）

给定 n，m，p，其中 p 是质数且不是很大，求

$$\binom{n}{m} \mod p$$

卢卡斯定理

$$
\binom{n}{m} = \binom{\lfloor \frac{n}{p} \rfloor} {\lfloor \frac{m}{p} \rfloor} \cdot \binom{n \mod p}{m \mod p} \pmod{p}
$$

#### 5.2.2 参考代码
```cpp
// Times of testing: 1
ll ksm(ll a, ll n, ll mod) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

ll inv(ll a, ll mod) {
    return ksm(a, mod - 2, mod);
}

// ll C(ll n, ll m, ll mod) {
//     if (m > n) return 0;
//     ll res = 1;
//     for (ll i = 1; i <= m; i++) {
//         res = res * (n - i + 1) % mod * inv(i, mod) % mod;
//     }
//     return res;
// }

// 优雅的组合数 C(n, m) mod p，要求 n, m < p，且 p 是质数
ll C(ll n, ll m, ll p) {
    if (m < 0 || m > n) return 0;
    if (m == 0 || m == n) return 1;

    // 利用对称性：C(n, m) = C(n, n-m)
    m = min(m, n - m);

    ll numerator = 1, denominator = 1;

    for (ll i = 0; i < m; i++) {
        numerator = numerator * (n - i) % p;      // (n)(n-1)...(n-m+1)
        denominator = denominator * (i + 1) % p;  // m!
    }

    return numerator * inv(denominator, p) % p;
}

ll Lucas(ll n, ll m, ll mod) {
    if (m == 0) return 1;
    if (n < mod && m < mod) return C(n, m, mod);
    return Lucas(n / mod, m / mod, mod) * C(n % mod, m % mod, mod) % mod;
}
```

### 5.3 斐波那契数列

#### 5.3.1 定义
斐波那契数列是一个经典的数列，其定义如下：
- $F(0) = 0$
- %F(1) = 1$
- $F(n) = F(n-1) + F(n-2), (n >= 2)$

#### 5.3.2 斐波那契数列的性质
- **卡西尼性质**：$F_{n-1}F_{n+1} - F_n^2 = (-1)^n$
- **加法公式**：$F_{n+m} = F_{n+1}F_m + F_nF_{m-1}$
- $F_{2n} = F_n \cdot (F_{n+1} + F_{n-1})$
- $\forall n, k \in \mathbb{N^+}, F_n|F_{nk}$
- 若 $a >= 3$，则 $F_a|F_b \Longleftrightarrow a|b$
- **GCD性质**：$gcd(F_n, F_m) = F_{gcd(n, m)}$
- $gcd(F_n, F_{n + 1}) = 1$

#### 5.3.3 矩阵快速幂计算

##### 3.3.1 数学原理
斐波那契数列的递推可以用矩阵乘法的形式表达为：
$$\begin{bmatrix}
F(n) & F(n-1)
\end{bmatrix} =
\begin{bmatrix}
F(n-1) & F(n-2)
\end{bmatrix} \cdot
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix} =
\begin{bmatrix}
1 & 0 \end{bmatrix}
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^{n-1} (n \geq 2)$$

##### 3.3.2 C++实现
```cpp
const ll MOD = 1e9 + 7;

struct Matrix {
    vector<vector<ll> > mat;
    int n, m;

    Matrix(int n_, int m_) : n(n_), m(m_) {
        mat.resize(n, vector<ll>(m, 0));
    }

    // 矩阵乘法
    Matrix operator*(const Matrix &B) const {
        Matrix result(n, B.m);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < B.m; ++j) {
                for (int k = 0; k < m; ++k) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * B.mat[k][j]) % MOD;  // % mod
                }
            }
        }
        return result;
    }

    // 只对方阵有效
    Matrix operator^(ll power) const {
        Matrix result(n, m);
        for (int i = 0; i < n; ++i) {
            result.mat[i][i] = 1;
        }
        Matrix base = *this;

        while (power) {
            if (power & 1) {
                result = result * base;
            }
            base = base * base;
            power >>= 1;
        }
        return result;
    }
};

ll fibonacci(ll n) {
    if (n == 0) return 0;
    if (n == 1) return 1;

    Matrix fib(2, 2);
    fib.mat[0][0] = 1; fib.mat[0][1] = 1;
    fib.mat[1][0] = 1; fib.mat[1][1] = 0;

    Matrix result = fib ^ (n - 1);
    return result.mat[0][0];
}
```

#### 5.3.4 快速倍增法

##### 3.4.1 数学原理

$$F_{2k} = F_k \cdot (2F_{k+1} - F_k)$$

$$F_{2k+1} = F_{k+1}^2 + F_k^2$$

于是可以通过这样的方法快速计算两个相邻的斐波那契数（常数比矩乘小）。

##### 3.4.2 C++实现
```cpp
// 返回 f(n) 和 f(n + 1)
pair<ll, ll> fib(ll n) {
  if (n == 0) return {0, 1};
  auto p = fib(n >> 1);
  ll c = p.first * (2 * p.second - p.first);
  ll d = p.first * p.first + p.second * p.second;
  if (n & 1) return {d, c + d};
  return {c, d};
}
```

#### 5.3.5 求和公式
斐波那契数列前 $n$ 项和为
$$S(n) = F(n + 2) - 1$$

- 证明：
$$S(n) = F(0) + F(1) + F(2) + ... + F(n) = F(n + 2) - 1$$
证毕。

### 5.4 卡特兰数（Catalan Number）

#### 5.4.1 定义

卡特兰数是组合数学中的一个重要数列，通常用 $C_n$表示，其定义为：
$$C_n = \frac{1}{n + 1} C(2n, n) = \frac{(2n)!}{(n + 1)!n!}$$

卡特兰数的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ...
- $C_0 = 1$
- $C_1 = 1$
- $C_2 = 2$

#### 5.4.2 应用
卡特兰数在许多组合问题中都有应用，包括：
- 有效括号序列的数量
- 二叉树的不同形状数量
- 平面二叉树的数量
- 分割凸多边形的方式数量

#### 5.4.3 计算公式
卡特兰数可以通过递推公式计算：
$$C_n = \sum_{i=0}^{n-1} C_i C_{n-1-i}, n \geq 2$$

$$C_n = \frac{(4n - 2)}{n + 1} C_{n-1}, n \geq 1$$

$$C_n = C(2n, n) - C(2n, n - 1)$$


### 5.5 默慈金数（Motzkin数）
#### 5.5.1 定义
Motzkin数是组合数学中的一个数列，前几项为：1, 1, 2, 4, 9, 21, 51, 127, 323, ...通常用 $M_n$ 表示，其定义为：
$$M_n = \sum_{i=0}^{\lfloor n/2 \rfloor} Catalan(i) \cdot C(n, 2i)$$

$$M_n = \frac{(2n + 1)M_{n - 1} + (3n-3)M_{n - 2}}{n + 2} = M_{n-1} + \sum_{k=0}^{n-2}M_kM_{n-2-k} \qquad (n >= 2)$$


## 6 其它

### 6.1 傅里叶变换

#### 6.1.1 快速傅里叶变换（FFT、IDFT，多项式系数表示法 <-> 点值表示法）

```cpp
// Times of testing: 3
const double PI = acos(-1.0);

// 二进制位翻转，需保证 n 是 2 的幂
void bit_reverse(std::vector<std::complex<double> > &a, int len) {
    if (len <= 0) return;
    if (len & (len - 1)) throw std::runtime_error("n必须是2的幂");
    std::vector<int> rev(len);    // rev[i]: i 翻转后的值
    rev[0] = 0;
    for (int i = 0; i < len; ++i) {
        rev[i] = rev[i >> 1] >> 1;
        if (i & 1) rev[i] |= (len >> 1);
    }
    for (int i = 0; i < len; ++i) {
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    }
}

// 原地 FFT，len 必须是 2 的幂
void fft(std::vector<std::complex<double> > &a, int len, int inv) {
    bit_reverse(a, len);
    // 合并过程，从长度为 1 合并为长度为 2，一直合并到长度为 len
    for (int h = 2; h <= len; h <<= 1) {
        std::complex<double> wn(std::cos(2 * PI / h), sin(inv * 2 * PI / h));
        // 合并，共 len / h 次
        for (int j = 0; j < len; j += h) {
            // 计算当前单位复根，一开始是 1 = w^0_n，之后是以 wn 为间隔递增： w^1_n
            std::complex<double> w(1, 0);
            for (int k = j; k < j + h / 2; ++k) {
                std::complex<double> u = a[k], t = w * a[k + h / 2];
                a[k] = u + t;
                a[k + h / 2] = u - t;
                w *= wn;
            }
        }
    }

    // 如果是 IDFT，它的逆矩阵的每一个元素不只是原元素取倒数，还要除以长度 len。
    if (inv == -1) {
        for (int i = 0; i < len; ++i) {
            a[i] /= len;
        }
    }
}
```

### 6.2 矩阵快速幂


```cpp
struct Matrix {
    vector<vector<int64_t> > mat;
    int n, m;

    Matrix(int n_, int m_) : n(n_), m(m_) {
        mat.resize(n, vector<int64_t>(m, 0));
    }

    // 矩阵乘法
    Matrix operator*(const Matrix &B) const {
        Matrix result(n, B.m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < B.m; ++j) {
                for (int k = 0; k < m; ++k) {
                    result.mat[i][j] += mat[i][k] * B.mat[k][j];    // % mod
                }
            }
        }
        return result;
    }

    // 只对方阵有效
    Matrix operator^(int64_t power) const {
        Matrix result(n, m);
        for (int i = 0; i < n; ++i) {
            result.mat[i][i] = 1;
        }
        Matrix base = *this;

        while (power) {
            if (power & 1) {
                result = result * base;
            }
            base = base * base;
            power >>= 1;
        }
        return result;
    }
};
```


### 6.3 莫队算法

#### 6.3.1 基础莫队算法

##### 6.3.1.1 算法简介


##### 6.3.11.2 示例

- **查询指定区间中不同的数的个数**
> 问题描述：
> 现有数列 $A_1, A_2, ..., A_N$，$Q$ 个询问 $(L_i, R_i)$，问 $A_{L_i}, A_{L_i+1}, ..., A_{R_i}$ 中不同的数的数量。
> 数据范围：
> $1 <= N <= 3 \times 10^4, 1 <= Q <= 10^5，1 <= A_i <= 10^6, 1 <= L_i <= R_i <= N$

- **示例代码**
```c++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
struct Query {
    int l, r, block, id;
    bool operator < (const Query &b) {
        return block == b.block ? r < b.r : block < b.block;
    }
};
int num;    // 区间中不同的数的数量
int a[30005];                   // 3e4
int cnt[1000005], ans[200005];  // 1e6, 2e5
Query q[200005];                // 2e5
void add(int x) {               // 加入 a[x]
    cnt[a[x]]++;
    if (cnt[a[x]] == 1) num++;
}
void remove(int x) {            // 移除 a[x]
    cnt[a[x]]--;
    if (cnt[a[x]] == 0) num--;
}
int main() {
    int n, m, l, r, block_size;
    cin >> n;
    block_size = sqrt(n);
    for (int i = 1; i <= n; i++) cin >> a[i];
    cin >> m;
    for (int i = 1; i <= m; i++) {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
        q[i].block = (q[i].l - 1) / block_size + 1; //
    }
    sort(q + 1, q + m + 1);
    l = r = q[1].l;         // 初始化
    num = cnt[a[l]] = 1;    // 初始化
    for (int i = 1; i <= m; i++) {
        while (l < q[i].l) remove(l++);
        while (l > q[i].l) add(--l);
        while (r < q[i].r) add(++r);
        while (r > q[i].r) remove(r--);
        ans[q[i].id] = num;
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
    return 0;
}
```

#### 6.3.2 带修改的莫队算法

##### 6.3.2.1 算法简介

##### 6.3.2.2 示例
```cpp
/*
 * Source of the problem: Unknow
 * File: G - 数颜色 维护队列.cpp
 * File Created: Saturday, 2025-07-05 11:23:05
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 */
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 133333 + 5;
const int MAXV = 1e6 + 5;

struct Query {
    int l, r, t, block_l, block_r, id;
    bool operator < (const Query &b) const {
        if (block_l != b.block_l) return block_l < b.block_l;
        if (block_r != b.block_r) return block_r < b.block_r;
        return t < b.t;
    }
};

int cnt[MAXV];
int a[N];
int num, l, r, t;   // t: 执行了前 t 个修改操作
pair<int, int> f[N];
Query q[N];

inline void add_l() {   // l 右移
    cnt[a[l]]--;
    if (cnt[a[l]] == 0) num--;
    l++;
}
inline void del_l() {   // l 左移
    l--;
    cnt[a[l]]++;
    if (cnt[a[l]] == 1) num++;
}
inline void add_r() {
    r++;
    cnt[a[r]]++;
    if (cnt[a[r]] == 1) num++;
}
inline void del_r() {
    cnt[a[r]]--;
    if (cnt[a[r]] == 0) num--;
    r--;
}
inline void add_t() {
    t++;
    if (f[t].first >= l && f[t].first <= r) {   // 影响当前区间
        int tmp = a[f[t].first];
        // 将 a[f[t].first] 修改为 f[t].second
        cnt[a[f[t].first]]--;
        if (cnt[a[f[t].first]] == 0) num--;
        a[f[t].first] = f[t].second;
        cnt[a[f[t].first]]++;
        if (cnt[a[f[t].first]] == 1) num++;
        f[t].second = tmp;
    }
    else {
        swap(a[f[t].first], f[t].second);
    }
}
inline void del_t() {
    if (f[t].first >= l && f[t].first <= r) {
        int tmp = a[f[t].first];
        // 将 a[f[t].first] 修改为 f[t].second
        cnt[a[f[t].first]]--;
        if (cnt[a[f[t].first]] == 0) num--;
        a[f[t].first] = f[t].second;
        cnt[a[f[t].first]]++;
        if (cnt[a[f[t].first]] == 1) num++;
        f[t].second = tmp;
    }
    else {
        swap(a[f[t].first], f[t].second);
    }
    t--;
}

int main() {
    int n, m, p, c;
    int query_cnt = 0, ffy_cnt = 0;
    char opt;
    cin >> n >> m;
    int block_size = pow(MAXV, 2.0 / 3);    // 分块大小
    for (int i = 1; i <= n; i++) cin >> a[i];   // 输入 a[i]
    for (int i = 1; i <= m; i++) {
        cin >> opt;
        if (opt == 'Q') {   // 查询操作
            cin >> l >> r;
            Query qq;
            query_cnt++;
            qq.l = l;
            qq.r = r;
            qq.t = ffy_cnt;
            qq.block_l = (l - 1) / block_size + 1;
            qq.block_r = (r - 1) / block_size + 1;
            qq.id = query_cnt;
            q[query_cnt] = qq;
        }
        else if (opt == 'R') {  // 修改操作
            cin >> p >> c;
            ffy_cnt++;
            f[ffy_cnt] = {p, c};
        }
    }
    sort(q + 1, q + query_cnt + 1);
    vector<int> ans(query_cnt + 1);
    // 计算第一个区间
    l = q[1].l;
    r = l - 1;
    t = 0;
    while (r < q[1].r) {
        add_r();
    }
    while (t < q[1].t) {
        add_t();
    }
    ans[q[1].id] = num;
    for (int i = 2; i <= query_cnt; i++) {
        while (l < q[i].l) add_l();
        while (l > q[i].l) del_l();
        while (r < q[i].r) add_r();
        while (r > q[i].r) del_r();
        while (t < q[i].t) add_t();
        while (t > q[i].t) del_t();
        ans[q[i].id] = num;
    }
    for (int i = 1; i <= query_cnt; i++) cout << ans[i] << '\n';

    return 0;
}
```


### 6.4 模拟退火

#### 6.4.1 算法简介

模拟退火（Simulated Annealing, SA）是一种基于概率的优化算法，灵感来源于金属退火过程。它通过模拟高温下分子运动逐渐冷却的过程，用于在复杂搜索空间中寻找全局最优解。算法通过接受次优解以跳出局部最优，适用于解决组合优化问题，如旅行商问题（TSP）、函数优化等。

#### 6.4.2 算法流程

1. **初始化**：选择初始解 $x_0$，设置初始温度 $T_0$，冷却系数 $\alpha$，终止温度 $T_{\text{end}}$。
1. **生成新解**：通过扰动当前解 $x_0$ 生成新解 $x'$。**随机扰动**或向**更优秀**的方向移动。
1. **接受准则**：计算新解与当前解的目标函数差 $\Delta E = f(x') - f(x_0)$。
若 $\Delta E \leq 0$，接受新解 $x'$。
若 $\Delta E > 0$，则以概率 $P = e^{- \frac {\Delta}{T}}$ 接受新解。


1. **更新温度**：按冷却策略（通常 $T = T \cdot \alpha $）降低温度。
1. **终止条件**：若温度低于 $T_{\text{end}}$ 或达到最大迭代次数，停止并返回最优解。

#### 6.4.3 c++伪代码
```cpp
// 计算函数值
double f(double x) {
    double ans = ...
    ...
    return ans;
}

void sa() {
    double t = 1000;        // 初始温度
    double a = 0.995;       // 降温系数
    double eps = 1e-15;     // 最低温度

    double x0 = 0;     // 初始解

    while (t > eps) {
        // 新解，随机扰动
        // 或向更优秀的方向移动
        double x1 = x0 + (2 * rand() - RAND_MAX) * t;
        // 若新解不在定义域可能要重新生成
        while (x1 > maxv || x1 < minv) x1 = x0 + (2 * rand() - RAND_MAX) * t;

        double delta = f(x1) - f(x0);   // 目标函数差
        if (delta < 0) {                // 当前值更小，并且是求最小值问题，则接受新解
            // 接受新解、更新答案
        }
        else if (exp(-delta / t) * RAND_MAX > rand()) {  // 否则以一定概率接受新解
            // 接受新解
        }
    }

    t *= a; // 降温
}

```

#### 6.4.4 多次运行

模拟退火算法可能取得局部最优解甚至错误解，在时间允许的情况下可以多次运行，提高找到全局最优解的概率。
- **控制运行次数示例 1**
```cpp
int main() {
    double time_limit = 1900;   // 时间限制，毫秒数
    auto start = chrono::high_resolution_clock::now();
    srand(time(0));
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y >> p[i].c;
    }

    auto end = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
    double time_used = duration.count() / 1000.0;;  // 毫秒数

    while (1) {
        start = chrono::high_resolution_clock::now();
        sa();
        end = chrono::high_resolution_clock::now();
        duration = chrono::duration_cast<chrono::microseconds>(end - start);
        time_ms = duration.count() / 1000.0; // 毫秒数
        time_used += time_ms;

        if (time_ms * 2 > time_limit - time_used) break; // 剩余时间不多就退出，乘 2 可能过于保守
    }

    cout << fixed << setprecision(10) << ans << '\n';

    return 0;
}
```

- **控制运行次数示例 2**
```cpp
int main() {
    double time_limit = 1900;   // 时间限制，毫秒数
    double time_used = 0;
    auto start = chrono::high_resolution_clock::now();
    auto set_time = [&] () {start = chrono::high_resolution_clock::now();};
    auto get_time = [&] () {
        auto duration = chrono::duration_cast<chrono::microseconds>(chrono::high_resolution_clock::now() - start);
        return duration.count() / 1000.0;
    };
    
    set_time();
    srand(time(0));
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> p[i].x >> p[i].y >> p[i].c;
    }
    time_used = get_time(); // 输入所需的时间

    while (1) {
        set_time();
        sa();
        time_used += get_time();    // get_time() 单次模拟退火的时间
        if (get_time() > time_limit - time_used) break; // 剩余时间不多就退出
    }

    cout << fixed << setprecision(10) << ans << '\n';

    return 0;
}
```

### 6.5 分块
```cpp
/*
 * Source of the problem: Unknow
 * File: E - 数列分块入门 5.cpp
 * File Created: Friday, 2025-07-04 14:54:24
 * Author: 犯困的00后最喜欢夏天
 * Result: Accepted
 */
#include <iostream>
#include <cmath>

using namespace std;
using ll = long long;

const int N = 5e4 + 5;
const int K = 3e2;

int a[N], f[K], st[K], ed[K], belong[N];
ll sum[K];
int t, block;

// 区间 [l, r] 每个数开方
void update(int l, int r) {
    if (belong[l] == belong[r]) {
        if (f[belong[l]]) return;
        int flag = 0;
        for (int i = l; i <= r; i++) {
            a[i] = sqrt(a[i]);
            if (a[i] > 1) flag = 1;
        }
        // 重新计算 sum[belong[l]]
        sum[belong[l]] = 0;
        for (int i = st[belong[l]]; i <= ed[belong[l]]; i++) sum[belong[l]] += a[i];
        if (l == st[belong[l]] && r == ed[belong[r]] && flag == 0) f[belong[l]] = 1;    // 后续无需更新
    }
    else {
        update(l, ed[belong[l]]);
        update(ed[belong[l]] + 1, r);
    }
}

// 区间和
ll query(int l, int r) {
    ll res = 0;
    if (belong[l] == belong[r]) {
        for (int i = l; i <= r; i++) {
            res += a[i];
        }
    }
    else {
        res = query(l, ed[belong[l]]) + query(st[belong[r]], r);
        for (int i = belong[l] + 1; i < belong[r]; i++) res += sum[i];
    }

    return res;
}

int main() {
    int n, opt, l, r, c;
    cin >> n;
    block = sqrt(n);    // 分块大小
    t = (n + block - 1) / block;    // 块的数量
    for (int i = 1; i <= t; i++) {
        st[i] = (i - 1) * block + 1;
        ed[i] = st[i] + block - 1;
    }
    ed[t] = n;  // 调整最后一块的边界
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        belong[i] = (i - 1) / block + 1;
        sum[belong[i]] += a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> opt >> l >> r >> c;
        if (opt == 0) {
            update(l, r);
        }
        else if (opt == 1) {
            cout << query(l, r) << '\n';
        }
    }

    return 0;
}
```

### 6.6 快速乘（避免、检测溢出）
```cpp
ll turtle_multiplication(ll a, ll b) {
    ll res = 0;
    while (b != 0) {
        if (a > 2e18) return -1;
        if (b & 1) res += a;
        a <<= 1;
        b >>= 1;
        if (res > 2e18) return -1;  // 溢出
    }
    return res;
}
```

## 7 数值算法

### 7.1 高斯消元
高斯消元法是求解线性方程组的常用方法。其基本思想是通过初等行变换将矩阵化为上三角形或阶梯形，从而便于求解。

#### 7.1.1 高斯消元法步骤
1. **选择主元**：在每一列中选择一个非零元素作为主元，通常选择绝对值最大的元素以提高数值稳定性。
2. **行变换**：通过行变换将主元所在列下方的元素消为零。
3. **回代**：从最后一行开始，逐步向上求解未知数。

#### 7.1.2 c++参考代码
```cpp
// Times of testing: 1
// 高斯消去法求解线性方程组 Ax = b，A 必须是方阵，b 大小与 A 行数一致
// 存在唯一解返回 true，否则返回 false
bool gaussian_elimination(vector<vector<double> > A, vector<double> b, vector<double>& x) {
    int n = A.size();
    for (int k = 0; k < n; k++) {   // 前向消去，将 A 化为上三角矩阵
        int pivot = k;              // 寻找主元（部分主元选择，避免数值不稳定）
        double max_val = abs(A[k][k]);
        for (int i = k + 1; i < n; i++) {
            if (abs(A[i][k]) > max_val) {
                max_val = abs(A[i][k]);
                pivot = i;
            }
        }
        if (pivot != k) {   // 交换行
            swap(A[k], A[pivot]);
            swap(b[k], b[pivot]);
        }
        // 检查主元是否接近零
        if (abs(A[k][k]) < 1e-9) return false;

        for (int i = k + 1; i < n; i++) {   // 消去
            double factor = A[i][k] / A[k][k];
            for (int j = k; j < n; j++) A[i][j] -= factor * A[k][j];
            b[i] -= factor * b[k];
        }
    }
    
    // 回代求解
    x.resize(n);
    for (int i = n - 1; i >= 0; --i) {
        double sum = 0.0;
        for (int j = i + 1; j < n; j++) sum += A[i][j] * x[j];
        x[i] = (b[i] - sum) / A[i][i];
    }
    return true;
}
```

#### 7.1.3 c++参考代码2
```c++
// Times of testing: 0
// 高斯消去法求解线性方程组 Ax = b，A 必须是方阵，b 大小与 A 行数一致
// 无解返回 -1，无穷多解返回 0，唯一解返回 1
int gaussian_elimination(vector<vector<double> > A, vector<double> b, vector<double>& x) {
    int n = A.size();
    int r = 0;  // 记录矩阵的秩

    // 前向消元
    for (int k = 0; k < n && r < n; k++) {
        // 部分主元选择：在当前列k中，从第r行开始寻找最大主元
        int pivot = r;
        double max_val = abs(A[r][k]);
        for (int i = r + 1; i < n; i++) {
            if (abs(A[i][k]) > max_val) {
                max_val = abs(A[i][k]);
                pivot = i;
            }
        }

        // 如果找到的主元太小，视为零，跳过该列
        if (abs(A[pivot][k]) < 1e-9) {
            continue;
        }

        // 交换行
        if (pivot != r) {
            swap(A[r], A[pivot]);
            swap(b[r], b[pivot]);
        }

        // 消元操作
        for (int i = r + 1; i < n; i++) {
            double factor = A[i][k] / A[r][k];
            for (int j = k; j < n; j++) {
                A[i][j] -= factor * A[r][j];
            }
            b[i] -= factor * b[r];
        }

        r++;  // 增加秩
    }

    // 检查无解：增广矩阵的秩 > 系数矩阵的秩
    for (int i = r; i < n; i++) {
        if (abs(b[i]) > 1e-9) {
            return -1;
        }
    }

    // 检查无穷多解：系数矩阵的秩 < 未知数个数
    if (r < n) {
        return 0;
    }

    // 唯一解：回代求解
    x.resize(n);
    for (int i = n - 1; i >= 0; i--) {
        double sum = 0.0;
        for (int j = i + 1; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        x[i] = (b[i] - sum) / A[i][i];
    }

    return 1;
}
```

### 7.2 矩阵求逆

#### 7.2.1 高斯-约当消元法求解逆矩阵（c++代码）

```c++
// 计算模意义下的逆矩阵
// Times of testing: 1
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

const ll mod = 1e9 + 7;

ll ksm(ll a, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

ll inv(ll a) {
    return ksm(a, mod - 2);
}

// 计算模意义下的逆矩阵，存在逆矩阵返回 true，不存在返回 false
bool inverse_matrix(vector<vector<ll> > &A, vector<vector<ll> > &res) {
    int n = A.size();
    for (int i = 0; i < n; i++) {
        A[i].resize(2 * n, 0);
        A[i][i + n] = 1;
    }
    // 向前消去
    for (int i = 0; i < n; i++) {
        int row = i;
        // 选主元
        for (int j = i + 1; j < n; j++) {
            if (A[j][i] > A[row][i]) {
                row = j;
            }
        }
        if (row != i) swap(A[i], A[row]);
        if (A[i][i] == 0) return false;     // 不存在逆矩阵
        for (int j = 0; j < n; j++) {
            if (j == i) continue;
            ll a = A[j][i] * inv(A[i][i]) % mod;
            for (int k = i; k < 2 * n; k++) {
                A[j][k] = ((A[j][k] - a * A[i][k]) % mod + mod) % mod;
            }
        }
        // 归一化
        ll a = inv(A[i][i]);
        for (int j = i; j < 2 * n; j++) A[i][j] = A[i][j] * a % mod;
    }

    res.resize(n, vector<ll>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            res[i][j] = A[i][j + n];
        }
    }
    return true;
}
```

## 8 图论

### 8.1 Least Common Ancestor（LCA）
```cpp
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

const int N = 1e3 + 5;
const int K = 20;   // 最大跳跃步数的对数

vector<int> g[N];
int deep[N], fa[N][K + 1];

// 根结点深度为 1
void getDeep(int now, int father) {
    deep[now] = deep[father] + 1;
    fa[now][0] = father;
    // for (int i = 1; (1 << i) < deep[now]; i++) {
    for (int i = 1; i <= K; i++) {
        fa[now][i] = fa[fa[now][i - 1]][i - 1];
    }
    for (int i = 0; i < g[now].size(); i++) {
        if (g[now][i] == father) continue;
        getDeep(g[now][i], now);
    }
}

int lca(int u, int v) {
    int deepu = deep[u], deepv = deep[v];
    if (deepu != deepv) {
        if (deepu < deepv) {    // 确保 u 的深度更深
            swap(u, v);
            swap(deepu, deepv);
        }
        int d = deepu - deepv;  // u 向上跳 d 步
        for (int i = 0; i <= K; i++) {
            if ((1 << i) & d) {
                u = fa[u][i];
            }
        }
    }
    // 现在 u 和 v 在同一高度
    if (u == v) return u;
    for (int i = K; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T, n, m, q, u, v, cnt = 1;
    ll ans;
    cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 1; i <= n; i++) {
            g[i].clear();
            deep[i] = 0;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= K; j++) {
                fa[i][j] = 0;
            }
        }
        for (int i = 1; i <= n; i++) {
            cin >> m;
            for (int j = 1; j <= m; j++) {
                cin >> u;
                g[u].push_back(i);
                g[i].push_back(u);
            }
        }
        getDeep(1, 0);
        cin >> q;
        cout << "Case " << cnt++ << ":\n";
        for (int i = 1; i <= q; i++) {
            cin >> u >> v;
            cout << lca(u, v) << "\n";
        }
    }

    return 0;
}
```