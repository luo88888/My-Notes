## 树

### 1 线段树


### 2 树状数组


### 3 树链剖分（HLD）（重链剖分）

- [树链剖分](https://oi-wiki.org/graph/hld/) 是一种将树转化为链的技巧，常用于处理树上的路径查询和修改问题。树链剖分有多种形式，如**重链剖分**和**长链剖分**，大多数情况下**树链剖分**指的就是**重链剖分**。下面只讲重链剖分。

#### 3.1 一些定义

- **重子节点**：在树链剖分中，重子节点是指子树中最大的子节点， 若有多个最大的子节点，可以选择任意一个。
- **轻子节点**：在树链剖分中，轻子节点是指子树中不是重子节点的子节点。
- **重边**：到达重子节点的边称为重边。
- **轻边**：到达轻子节点的边称为轻边。
- **重链**：若干条重边连接起来路径称为重链。
- **轻链**：与重链相对，轻链是指不在重链上的边。

#### 3.2 重链剖分的实现
- 重链剖分的实现分为两个 DFS 过程：
- 第一个 DFS 获取以下数组：
    - `size[i]`：节点 `i` 的子树大小。
    - `deep[i]`：节点 `i` 的深度。
    - `big_son[i]`：节点 `i` 的重子节点。
    - `father[i]`：节点 `i` 的父节点。
- 第二个 DFS 获取以下数组：
    - `top[i]`：节点 `i` 所在重链的顶点。
    - `dfn[i]`：节点 `i` 的 DFS 序号。

#### 3.3 数链剖分计算 LCA
```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 5e5 + 5;

vector<int> g[N];
int deep[N];    // 节点深度
int fa[N];      // 父节点
int siz[N];     // 子树的节点数量
int son[N];     // 重儿子
int top[N];     // top[x]: x 所在重链的链头

// 计算 deep[]、fa[]、size[]、son[]
int dfs1(int cur, int father, int d) {
    int node_cnt = 1;
    int big_son = 0, max_cnt = 0;
    deep[cur] = d;
    fa[cur] = father;
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father) continue;
        int t = dfs1(g[cur][i], cur, d + 1);
        node_cnt += t;
        if (t > max_cnt) {
            max_cnt = t;
            big_son = g[cur][i];
        }
    }
    siz[cur] = node_cnt;
    son[cur] = big_son;
    return node_cnt;
}

// 计算 top[]
void dfs2(int cur, int father, int head) {
    top[cur] = head;
    if (son[cur] != 0) dfs2(son[cur], cur, head);   // 先递归搜索重儿子，确保重链内节点 DFS 序连续
    for (int i = 0; i < g[cur].size(); i++) {
        if (g[cur][i] == father || g[cur][i] == son[cur]) continue;
        dfs2(g[cur][i], cur, g[cur][i]);    // 轻儿子，另一条重链的链头
    }
}

int lca(int u, int v) {
    while (top[u] != top[v]) {  // 不在同一条重链
        if (deep[top[u]] > deep[top[v]]) u = fa[top[u]];
        else v = fa[top[v]];
    }
    if (deep[u] < deep[v]) return u;
    return v;
}

int main() {
    int n, m, root, u, v;
    cin >> n >> m >> root;
    for (int i = 1; i <= n - 1; i++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(root, 0, 1);
    dfs2(root, 0, root);
    for (int i = 1; i <= m; i++) {
        cin >> u >> v;
        cout << lca(u, v) << '\n';
    }

    return 0;
}
```
    


### 4 最近公共祖先

- [最近公共祖先](https://oi-wiki.org/graph/lca/)（LCA）是树上常见的查询问题，用于查询两个节点的最近公共祖先。LCA 的求解方法有多种，常用的有倍增法、tarjan 算法（离线算法）和树链剖分等。下面介绍倍增法。

```c++
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
const int K = 20; // 2^K >= N
// const int K = log2(N) + 1;
vector<int> g[N];
int fa[N][K]; // fa[i][j] 表示节点 i 的 2^j 祖先
int deep[N]; // 节点深度

// 节点编号从 1 开始
void dfs(int cur, int father) {
    fa[cur][0] = father; // 2^0 祖先
    deep[cur] = deep[father] + 1;
    for (int i = 1; i < K; i++) {
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1]; // 2^i 祖先
    }
    for (int next : g[cur]) {
        if (next != father) dfs(next, cur);
    }
}

int lca(int u, int v) {
    if (deep[u] < deep[v]) swap(u, v); // 确保 u 深度大于等于 v
    // 提升 u 到与 v 同一深度
    for (int i = K - 1; i >= 0; i--) {
        if (deep[fa[u][i]] >= deep[v]) {
            u = fa[u][i];
        }
    }
    if (u == v) return u; // 如果已经相等，直接返回
    // u, v 一起向上跳
    for (int i = K - 1; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0]; // 返回最近公共祖先
}
```

### 5 树的直径
- 树的直径是指树中任意两个节点之间的最长路径长度。可以通过两次 BFS 或 DFS 来求解树的直径。

- 步骤：
  1. 从任意节点开始，使用 BFS 或 DFS 找到距离最远的节点 A。
  2. 从节点 A 开始，再次使用 BFS 或 DFS 找到距离最远的节点 B，此时 A 和 B 之间的距离即为树的直径。


### 6 树的重心

- 树的重心是指树中一个或多个节点，使得从这些节点出发到达其他所有节点的最大距离最小。重心可以通过 DFS 来求解。

- 步骤：
  1. 对树进行 DFS，计算每个节点的子树大小。
  2. 对于每个节点，计算其作为重心时的最大子树大小。
  3. 找到使得最大子树大小最小的节点，即为重心。

