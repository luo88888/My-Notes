## 组合数学

### 1 组合数
#### 1.1 定义
组合数 $C(n, m)$ 表示从 $n$ 个不同的元素中选出 $m$ 个元素的不同选择方式的数量,常用 $C_{n}^{m}$ 或 $\binom{n}{m}$ 表示。。其计算公式为：
$$C(n, m) = \frac{n!}{m!(n-m)!}$$

### 2 卢卡斯定理（Lucas）

给定 n，m，p，其中 p 是质数且不是很大，求

$$\binom{n}{m} \mod p$$

卢卡斯定理

$$
\binom{n}{m} = \binom{\lfloor \frac{n}{p} \rfloor} {\lfloor \frac{m}{p} \rfloor} \cdot \binom{n \mod p}{m \mod p} \pmod{p}
$$

#### 2.2 参考代码
```cpp
// Times of testing: 1
ll ksm(ll a, ll n, ll mod) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

ll inv(ll a, ll mod) {
    return ksm(a, mod - 2, mod);
}

// ll C(ll n, ll m, ll mod) {
//     if (m > n) return 0;
//     ll res = 1;
//     for (ll i = 1; i <= m; i++) {
//         res = res * (n - i + 1) % mod * inv(i, mod) % mod;
//     }
//     return res;
// }

// 优雅的组合数 C(n, m) mod p，要求 n, m < p，且 p 是质数
ll C(ll n, ll m, ll p) {
    if (m < 0 || m > n) return 0;
    if (m == 0 || m == n) return 1;

    // 利用对称性：C(n, m) = C(n, n-m)
    m = min(m, n - m);

    ll numerator = 1, denominator = 1;

    for (ll i = 0; i < m; i++) {
        numerator = numerator * (n - i) % p;      // (n)(n-1)...(n-m+1)
        denominator = denominator * (i + 1) % p;  // m!
    }

    return numerator * inv(denominator, p) % p;
}

ll Lucas(ll n, ll m, ll mod) {
    if (m == 0) return 1;
    if (n < mod && m < mod) return C(n, m, mod);
    return Lucas(n / mod, m / mod, mod) * C(n % mod, m % mod, mod) % mod;
}
```

### 3 斐波那契数列

#### 3.1 定义
斐波那契数列是一个经典的数列，其定义如下：
- $F(0) = 0$
- %F(1) = 1$
- $F(n) = F(n-1) + F(n-2), (n >= 2)$

#### 3.2 斐波那契数列的性质
- **卡西尼性质**：$F_{n-1}F_{n+1} - F_n^2 = (-1)^n$
- **加法公式**：$F_{n+m} = F_{n+1}F_m + F_nF_{m-1}$
- $F_{2n} = F_n \cdot (F_{n+1} + F_{n-1})$
- $\forall n, k \in \mathbb{N^+}, F_n|F_{nk}$
- 若 $a >= 3$，则 $F_a|F_b \Longleftrightarrow a|b$
- **GCD性质**：$gcd(F_n, F_m) = F_{gcd(n, m)}$
- $gcd(F_n, F_{n + 1}) = 1$

#### 3.3 矩阵快速幂计算

##### 3.3.1 数学原理
斐波那契数列的递推可以用矩阵乘法的形式表达为：
$$\begin{bmatrix}
F(n) & F(n-1)
\end{bmatrix} =
\begin{bmatrix}
F(n-1) & F(n-2)
\end{bmatrix} \cdot
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix} =
\begin{bmatrix}
1 & 0 \end{bmatrix}
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^{n-1} (n \geq 2)$$

##### 3.3.2 C++实现
```cpp
const ll MOD = 1e9 + 7;

struct Matrix {
    vector<vector<ll> > mat;
    int n, m;

    Matrix(int n_, int m_) : n(n_), m(m_) {
        mat.resize(n, vector<ll>(m, 0));
    }

    // 矩阵乘法
    Matrix operator*(const Matrix &B) const {
        Matrix result(n, B.m);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < B.m; ++j) {
                for (int k = 0; k < m; ++k) {
                    result.mat[i][j] = (result.mat[i][j] + mat[i][k] * B.mat[k][j]) % MOD;  // % mod
                }
            }
        }
        return result;
    }

    // 只对方阵有效
    Matrix operator^(ll power) const {
        Matrix result(n, m);
        for (int i = 0; i < n; ++i) {
            result.mat[i][i] = 1;
        }
        Matrix base = *this;

        while (power) {
            if (power & 1) {
                result = result * base;
            }
            base = base * base;
            power >>= 1;
        }
        return result;
    }
};

ll fibonacci(ll n) {
    if (n == 0) return 0;
    if (n == 1) return 1;

    Matrix fib(2, 2);
    fib.mat[0][0] = 1; fib.mat[0][1] = 1;
    fib.mat[1][0] = 1; fib.mat[1][1] = 0;

    Matrix result = fib ^ (n - 1);
    return result.mat[0][0];
}
```

#### 3.4 快速倍增法

##### 3.4.1 数学原理

$$F_{2k} = F_k \cdot (2F_{k+1} - F_k)$$

$$F_{2k+1} = F_{k+1}^2 + F_k^2$$

于是可以通过这样的方法快速计算两个相邻的斐波那契数（常数比矩乘小）。

##### 3.4.2 C++实现
```cpp
// 返回 f(n) 和 f(n + 1)
pair<ll, ll> fib(ll n) {
  if (n == 0) return {0, 1};
  auto p = fib(n >> 1);
  ll c = p.first * (2 * p.second - p.first);
  ll d = p.first * p.first + p.second * p.second;
  if (n & 1) return {d, c + d};
  return {c, d};
}
```

#### 3.5 求和公式
斐波那契数列前 $n$ 项和为
$$S(n) = F(n + 2) - 1$$

- 证明：
$$S(n) = F(0) + F(1) + F(2) + ... + F(n) = F(n + 2) - 1$$
证毕。

### 4 卡特兰数（Catalan Number）

#### 4.1 定义

卡特兰数是组合数学中的一个重要数列，通常用 $C_n$表示，其定义为：
$$C_n = \frac{1}{n + 1} C(2n, n) = \frac{(2n)!}{(n + 1)!n!}$$

卡特兰数的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ...
- $C_0 = 1$
- $C_1 = 1$
- $C_2 = 2$

#### 4.2 应用
卡特兰数在许多组合问题中都有应用，包括：
- 有效括号序列的数量
- 二叉树的不同形状数量
- 平面二叉树的数量
- 分割凸多边形的方式数量

#### 4.3 计算公式
卡特兰数可以通过递推公式计算：
$$C_n = \sum_{i=0}^{n-1} C_i C_{n-1-i}, n \geq 2$$

$$C_n = \frac{(4n - 2)}{n + 1} C_{n-1}, n \geq 1$$

$$C_n = C(2n, n) - C(2n, n - 1)$$


### 5 默慈金数（Motzkin数）
#### 5.1 定义
Motzkin数是组合数学中的一个数列，前几项为：1, 1, 2, 4, 9, 21, 51, 127, 323, ...通常用 $M_n$ 表示，其定义为：
$$M_n = \sum_{i=0}^{\lfloor n/2 \rfloor} Catalan(i) \cdot C(n, 2i)$$

$$M_n = \frac{(2n + 1)M_{n - 1} + (3n-3)M_{n - 2}}{n + 2} = M_{n-1} + \sum_{k=0}^{n-2}M_kM_{n-2-k} \qquad (n >= 2)$$