## 数论

数论是数学的一个分支，主要研究整数及其性质。数论涉及的内容非常广泛，包括但不限于素数、整除性、同余、数的分解、逆元、模运算等。数论在密码学、计算机科学和其他数学分支中有着重要的应用。


### 1 素数

#### 1.1 定义
素数也叫质数，是大于 1 的自然数，且只能被 1 和它本身整除。例如 2、3、5、7、11 都是素数。

#### 1.2 判断素数
判断一个数是否为素数可以使用 **试除法**。具体步骤如下：
1. 如果数小于 2，则不是素数。
2. 对于大于等于 2 的数 n，检查从 2 到 $\sqrt{n}$ 的所有整数是否能整除 n。
3. 如果存在一个整数能整除 n，则 n 不是素数；否则， n 是素数。
- c++示例，时间复杂度为 $O(\sqrt{n})$：
```cpp
bool isPrime(int n) {
    if (n < 2 || !(n & 1) && n != 2) return n == 2; // 2 是素数，其他偶数不是素数
    for (int i = 2; i * i <= n; i++) {  // 注意不要溢出
        if (n % i == 0) return false;
    }
    return true;
}
```

#### 1.3 埃拉托斯筛法（Sieve of Eratosthenes，埃氏筛，时间复杂度 $O(n \log \log n)$）
埃拉托斯筛法是一种高效的素数筛选算法，用于找出小于等于某个数 n 的所有素数。其基本思想是从 2 开始，依次将每个素数的倍数标记为非素数。
- c++示例：
```cpp
int n = 100; // 找出小于等于 n 的所有素数
vector<bool> isPrime(n + 1, true);
isPrime[0] = isPrime[1] = false;
for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) { // 如果 i 是素数
        for (int j = i * i; j <= n; j += i) {   // j = i * 2 效率略低，注意不要溢出
            isPrime[j] = false;
        }
    }
}
```

#### 1.4 欧拉筛法（Euler's Sieve，时间复杂度 $O(n)$）
欧拉筛也叫线性筛，是一种改进的素数筛选算法。它的核心思想是让每一个合数被最小的素数因子筛掉，从而避免了重复筛选。
- 合数 = 最小素数 * 自然数
- c++示例：
```cpp
int n = 100; // 找出小于等于 n 的所有素数
vector<bool> isPrime(n + 1, true); // true 表示素数，false 表示非素数
vector<int> primes; // 存储素数
isPrime[0] = isPrime[1] = false;
for (int i = 2; i <= n; i++) {
    if (isPrime[i]) { // 如果 i 是素数
        primes.push_back(i);
    }
    for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) {
        isPrime[i * primes[j]] = false; // 标记合数
        if (i % primes[j] == 0) break; // 确保每个合数只被最小素数因子筛掉
    }
}
```

### 2 最大公约数（greatest common divisor，GCD）

### 3 最小公倍数（least common multiple，LCM）

### 4 拓展欧几里得（Extended Euclidean Algorithm）

已知 $a$，$b$，拓展欧几里得可以求得 $gcd(a, b)$和 $ax + by = gcd(a, b)$的一组整数解 $x$ 与 $y$。推导过程如下：

$$gcd(a, b) = gcd(b, a \bmod b)$$

如果现在存在 $x_2$，$y_2$ 使得

$$bx_2 + (a \bmod b)y_2 = gcd(b, a \bmod b)$$

那么会有

$$ax + by = bx_2 + (a \bmod b)y_2 $$ $$\Downarrow$$

$$ax + by = bx_2 + (a - b \times (a / b))y_2$$

$$\Downarrow$$

$$ax + by = bx_2 + ay_2 - b \times (a / b)y_2$$

$$\Downarrow$$

$$ ax + by = ay_2 + b(x_2 - (a / b)y_2)$$

此时得到一组解

$$\left\{\begin{aligned}x&=y_2\\y&=x_2 - (a / b)y_2\end{aligned}\right.$$

可以采取**递归**的方法，重复这个过程直至**普通欧几里得算法**的**递归基**即$$b = 0$$

此时易知使得$ax_n + by_n = gcd(a, b)$成立，即
$$\left\{\begin{aligned}x_n&=1\\y_n&=0\end{aligned}\right.$$

在回溯过程中可计算得到 $x$，$y$

#### c++代码实现

```c++
// Times of testing: 2
using ll = long long;
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { // 递归终止
        x = 1;
        y = 0;
        return a;
    }
    ll gcd = exgcd(b, a % b, x, y);
    ll tmp = x;
    x = y;  // x = y_2
    y = tmp - (a / b) * y;  // y = x_2 - (a / b) * y_2
    return gcd;
}
```

### 5 逆元（Modular Inverse）
#### 5.1 定义

如果 $ab \equiv 1 \pmod{p}$，则 $a$ 和 $b$ 在模 $p$ 意义下互为**乘法逆元**。

#### 5.2 逆元存在的条件

$gcd(a, p) = 1$

#### 5.3 逆元的作用

除法取余: $\frac{a}{b} \bmod p = a \times inv(b) \bmod p$。其中$inv(b)$为 $b$ 在模 $p$ 意义下的乘法逆元。

#### 5.4 逆元的计算方法

##### 5.4.1 拓展欧几里得（通用）

$$
ab \equiv 1 \pmod p \Leftrightarrow ab = 1 + kp \Leftrightarrow ab - kp = 1
$$

把 $b$ 换成 $x$，$-k$ 换成 $y$，得到

$$
ax + py = 1
$$


解得的正整数 $x$ 即为 $a$ 在模 $p$ 下的逆元。

c++参考代码

```c++
// Times of testing: 1
using ll = long long;
// 拓展欧几里得
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll res = exgcd(b, a % b, x, y);
    ll tmp = x;
    x = y;
    y = tmp - (a / b) * y;
    return res;
}
ll inv(ll a, ll p) {
    ll x, y;
    ll gcd_res = exgcd(a, p, x, y);
    if (gcd_res != 1) return -1;    // 没有逆元
    return ((x % p) + p) % p;
}
```

##### 5.4.2 费马小定理（p 为质数，常用）

- 费马小定理：

> 如果 $p$ 是一个质数，$a$ 是一个整数且不能被 $p$ 整除（即 $a$ 与 $p$ 互质），那么有 $a^{p-1} \equiv 1 \pmod{p}$。换句话说，当一个整数 $a$ 与质数 $p$ 互质时，$a$ 的p-1次方除以 $p$ 的余数是1

由费马小定理可得 $a \times a^{p-2} \equiv 1 \pmod{p}$,因此 $a$ 在模 $p$ 意义下的一个逆元是 $a^{p-2}$，用**快速幂**可快速计算出。

c++参考代码

```c++
using ll = long long;
ll quick_pow(ll a, ll n, ll m) {   // 计算 (a ^ n) mod m
    ll res = 1;
    while (n) {
        if (n & 1) res = (res * a) % m;
        a = (a * a) % m;
        n >>= 1;
    }
    return res;
}
ll inv(ll a, ll p) { // 计算 a 在模 p 意义下的逆元，p 为素数
    return quick_pow(a, p - 2, p);
}
```

##### 5.4.3 线性递推、记忆化搜索（p 为素数）

设 $p = aq + r$，其中 $r = p \bmod a$，则 $q = \lfloor \frac{p}{a} \rfloor$

在模 $p$ 意义下，有 

$$
aq + r \equiv 0 \pmod{p}
$$


$$
\Downarrow
$$

$$
a = -r \times inv(q) \pmod{p}
$$

$$
\Downarrow
$$

$$
inv(a) = -q \times inv(r) \pmod{p}
$$

$$
\Downarrow
$$

$$
inv(a) = -\lfloor \frac{p}{a} \rfloor \times inv(p \bmod a) \pmod{p}
$$

线性递推 c++ 参考代码
```c++
// Times of testing: 0
// n 可以大于 p
int inv[N], p;  // inv[i]: i 在模 p 意义下的逆元，p 要为素数
void inverse_element_init(int n, int p) {
    for (int i = 0; i <= n; i++) inv[i] = 0;
    inv[1] = 1;

    for (int i = 2; i <= min(n, p-1); i++) {    // 计算 i < p 的逆元
        inv[i] = (((-p / i * inv[p % i]) % p) + p) % p;
    }

    for (int i = p; i <= n; i++) {  // 对于 i >= p 的情况，使用同余性质
        int r = i % p;
        inv[i] = (r == 0) ? 0 : inv[r]; // 直接复用 r 的逆元
    }
}
```

#### 5.5 阶乘的逆元

在模 $p$ 意义下，$a$ 的逆元和 $a \bmod p$ 的逆元是相等的，这是因为模 $p$ 的逆元是基于同余关系的，而同余关系满足以下性质：

* 如果 $a \equiv b \pmod p$，则 $a$ 和 $b$ 在模 $p$ 意义下的逆元是相等的。

显然，$a \bmod p \equiv (a \bmod p) \bmod p$，因此 $a$ 和 $a \bmod p$ 在模 $p$ 意义下的逆元是相等的。因此在模 $p$ 意义下 

$$
inv(n!) \equiv inv(n! \bmod p) \pmod p
$$


##### 5.5.1 阶乘逆元线性递推（条件：$p$ 为素数且 $n < p$）

$$
n! \times inv(n!) \equiv 1 \pmod p
$$

$$
\Downarrow
$$

$$
(n-1)! \times n \times inv(n!) \equiv 1 \pmod p
$$

由此得到递推公式：$inv((n-1)!) \equiv n \times inv(n!) \bmod p \pmod p$


### 6 线性同余方程
#### 6.1 定义
线性同余方程的形式为 $ax \equiv b \pmod{m}$，其中 $a$、$b$、$m$ 是已知整数，$x$ 是未知数，需要从区间 [0, m - 1] 中求解 $x$ 的值。

#### 6.2 解的存在性
线性同余方程 $ax \equiv b \pmod{m}$ 有解的充分必要条件是 $gcd(a, m)$ 能整除 $b$。如果 $gcd(a, m) = g$，则方程有 $g$ 个解。

#### 6.3 用逆元求解

如果 $gcd(a, m) = 1$，此时方程有**唯一解**，可以通过求 $a$ 的逆元来解方程。$$x \equiv a^{-1}b \pmod{m}$$

#### 6.4 用扩展欧几里得求解

- 线性同余方程 $ax \equiv b \pmod{m}$ 可以改写为 $ax + mk = b$，其中 $x$ 和 $k$ 是未知数，该方程有整数解的充分必要条件是 $gcd(a, m)$ 能整除 $b$。先求出 $ax + mk = gcd(a, m)$ 的一组整数解 $(x_0, k_0)$，然后将其乘以 $\frac{b}{gcd(a, m)}$，得到 $a\frac{b}{gcd(a, m)}x_0 + m\frac{b}{gcd(a, m)}k_0 = b$ 的一组整数解 $(\frac{b}{gcd(a, m)}x_0, \frac{b}{gcd(a, m)}k_0)$。


- 若 $gcd(a, m) = 1$，且 $x_0$，$k_0$ 为方程 $ax + mk = b$ 的一组解，则该方程的任意解可表示为：$$x=x_0+mt$$ $$k=k_0-at$$ t 为任意整数。

- 实际问题中，往往要求出一个最小整数解，也就是一个特解$$x=(x \bmod t + t) \bmod t$$其中$$t=\frac{m}{gcd(a, m)}$$


### 7 中国剩余定理 (Chinese Remainder Theorem, CRT)

#### 7.1 定义

中国剩余定理用于求解如下形式的一元线性同余方程组（其中 $m_1,m_2,...,m_k$ 是两两互质的正整数）：
$$\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}$$

#### 7.2 计算过程
1. 计算所有模数的积：$M = m_1 \times m_2 \times ... \times m_k$。
2. 对于每个 $i$，计算 $M_i = \frac{M}{m_i}$。
3. 计算 $M_i$ 在模 $m_i$ 意义下的逆元 $M_i^{-1}$，即满足 $M_i \cdot M_i^{-1} \equiv 1 \pmod{m_i}$。
4. 方程组在模 $M$ 意义下唯一解为：
$$x \equiv \sum_{i=1}^{k} a_i \cdot M_i \cdot M_i^{-1} \pmod{M}$$

#### 7.3 c++实现
```cpp
// Times of testing: 0
long CRT(const vector<long long>& a, const vector<long long>& m) {
    int k = a.size();
    long long M = 1, res = 0;

    // 计算所有模数的积
    for (int i = 0; i < k; i++) M *= m[i];

    // 对每个模数计算 M_i 和 M_i 的逆元
    for (int i = 0; i < k; i++) {
        long long Mi = M / m[i];
        long long Mi_inv = inv(Mi, m[i]); // 使用之前定义的 inv 函数
        res = (res + a[i] * Mi * Mi_inv) % M;
    }

    return (res + M) % M; // 确保结果为非负数
}
```

#### 7.4 扩展中国剩余定理（模数不互质）

##### 7.4.1

设两个方程分别是 $x \equiv a_1 \pmod {m_1}、x \equiv a_2 \pmod {m_2}$，将他们转化为不定方程：$x=m_1p+a_1=m_2q+a_2$，则有$$m_1p-m_2q=a_2-a_1$$由裴蜀定理，当 $a_2-a_1$ 不能被 $gcd(m_1,m_2)$ 整除时，无解；其他情况下，可以通过 扩展欧几里得算法 解出来一组可行解 $(p, q)$；
则原来的两方程组成的模方程组的解为 $x \equiv b \pmod M$，其中 $b=m_1p+a_1, M=lcm(m_1, m_2)$
- 若有多个方程，则用上面的方法两两合并即可

##### 7.4.2 c++ 代码
```c++
// Times of testing: 1
ll ex_gcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll g = ex_gcd(b, a % b, x, y);
    ll temp = x;
    x = y;
    y = temp - a / b * y;
    return g;
}

ll lcm(ll a, ll b) {
    ll x, y;
    return a / ex_gcd(a, b, x, y) * b;
}

// 解方程：x = a1 (mod m1), x = a2 (mod m2)，无解返回 false
// 解为 x = b (mod M)
bool ex_CRT(ll a1, ll m1, ll a2, ll m2, ll &b, ll &M) {
    ll p, q;
    ll g = ex_gcd(m1, m2, p, q);
    if ((a2 - a1) % g != 0) return false;
    M = lcm(m1, m2);
    p = ((__int128) p * (a2 - a1) / g % M + M) % M; // 使用__int127 防止中间值溢出
    b = (((__int128) m1 * p + a1) % M + M) % M;

    return true;
}

// 解 x = a (mod m) 的线性同余方程组，n >= 1，无解返回 false
bool ex_CRT(vector<ll> a, vector<ll> m, ll &b, ll &M) {
    b = a[0];
    M = m[0];
    for (int i = 1; i < a.size(); i++) {
        bool res = ex_CRT(a[i], m[i], b, M, b, M);
        if (res == false) return false;
    }
    return true;
}
```



### 8 欧拉函数

#### 8.1 定义

欧拉函数 $\phi(n)$ 是一个整数函数，表示小于等于 $n$ 的正整数中与 $n$ 互质的数的个数。换句话说，$\phi(n)$ 是 $1$ 到 $n$ 中与 $n$ 互质的整数的数量。

#### 8.2 欧拉函数的性质

1. **基本性质**：如果 $p$ 是素数，则 $\phi(p) = p - 1$。
2. **乘法性质**：如果 $a$ 和 $b$ 互质，则 $\phi(ab) = \phi(a) \cdot \phi(b)$。
3. **质因数分解**：如果 $n$ 的质因数分解为 $p_1^{k_1} \cdot p_2^{k_2} \cdots p_m^{k_m}$，则
   $$\phi(n) = n \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_m}\right)$$
4. **递推性质**：如果 $n$ 是一个正整数，则 $\phi(n)$ 可以通过以下递推公式计算：
   $$\phi(n) = n \cdot \prod_{p | n} \left(1 - \frac{1}{p}\right)$$
5. 当 $n$ 为奇数时，$\phi(2n) = \phi(n)$。
6. 当 $n > 2$ 时，$\phi(n)$ 是偶数。
7. 小于 $n$ 的数中，与 $n$ 互质的数的总和为 $\frac{n \cdot \phi(n)}{2}$。
6. $n = \sum_{d | n} \phi(d)$，其中 $d$ 是 $n$ 的所有正因数。（欧拉反演）
7. 若 $n=p^k$，其中 $p$ 是素数，则 $\phi(n) = p^k - p^{k-1} = p^{k-1}(p - 1)$。

#### 8.3 计算欧拉函数
计算欧拉函数的常用方法是通过质因数分解。对于一个正整数 $n$，可以先找到它的所有质因数，然后使用上述性质来计算 $\phi(n)$。
- c++ 示例代码：
```cpp
// Times of testing: 3
int phi(int n) {
    int result = n; // 初始化结果为 n
    for (long long i = 2; i * i <= n; i++) {
        if (n % i == 0) { // 如果 i 是 n 的一个质因数
            while (n % i == 0) {
                n /= i; // 除去所有的 i
            }
            result -= result / i; // 使用欧拉函数的性质
        }
    }
    if (n > 1) { // 如果 n 仍然大于 1，则它是一个质数
        result -= result / n;
    }
    return result;
}
```

#### 8.4 线性递推
欧拉函数也可以通过线性递推来计算。对于 $n$ 的每个正整数，可以使用以下递推公式：
$$\phi(n) = n \cdot \prod_{p | n} \left(1 - \frac{1}{p}\right)$$其中 $p$ 是 $n$ 的所有质因数。
- c++ 示例代码：
```cpp
// Times of testing: 3
vector<int> euler(int n) {
    vector<int> phi(n + 1);
    for (int i = 1; i <= n; i++) {
        phi[i] = i; // 初始化
    }
    for (int i = 2; i <= n; i++) {
        if (phi[i] == i) { // 如果 i 是素数
            for (int j = i; j <= n; j += i) {
                phi[j] -= phi[j] / i; // 更新欧拉函数值
            }
        }
    }
    return phi;
}
```
- 线性筛
```cpp
// Times of testing: 2
vector<int> euler_phi(int n) {
    vector<int> phi(n + 1);
    vector<int> primes;
    vector<bool> is_composite(n + 1, false);

    // 初始化
    phi[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!is_composite[i]) {
            primes.push_back(i);
            phi[i] = i - 1;  // i 是质数
        }
        // 线性筛：用每个数的最小质因子去筛
        for (int p : primes) {
            if (i * p > n) break;
            is_composite[i * p] = true;
            if (i % p == 0) {   // p 是 i 的最小质因子，且 p^2 | (i*p)
                phi[i * p] = phi[i] * p;
                break;
            }
            phi[i * p] = phi[i] * (p - 1);  // p 不整除 i，所以 gcd(i, p) = 1
        }
    }
    return phi;
}
```

#### 8.5 欧拉定理

若 $gcd(a, m) = 1$，则 $a^{\phi(m)} \equiv 1 \pmod m$

#### 8.6 扩展欧拉定理

$$a^b \equiv \begin{cases}
a^{b \bmod \phi(m)} \pmod m， & \text gcd(a, m) = 1 \\
a^{b} \pmod m， & \text gcd(a, m) \neq 1，b < \phi(m) \\
a^{b \bmod \phi(m) + \phi(m)} \pmod m， & \text gcd(a, m) \neq 1，b \geq \phi(m)
\end{cases}$$
