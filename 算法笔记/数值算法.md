## 数值算法

### 1 高斯消元
高斯消元法是求解线性方程组的常用方法。其基本思想是通过初等行变换将矩阵化为上三角形或阶梯形，从而便于求解。

#### 1.1 高斯消元法步骤
1. **选择主元**：在每一列中选择一个非零元素作为主元，通常选择绝对值最大的元素以提高数值稳定性。
2. **行变换**：通过行变换将主元所在列下方的元素消为零。
3. **回代**：从最后一行开始，逐步向上求解未知数。

#### 1.2 c++参考代码
```cpp
// Times of testing: 1
// 高斯消去法求解线性方程组 Ax = b，A 必须是方阵，b 大小与 A 行数一致
// 存在唯一解返回 true，否则返回 false
bool gaussian_elimination(vector<vector<double> > A, vector<double> b, vector<double>& x) {
    int n = A.size();
    for (int k = 0; k < n; k++) {   // 前向消去，将 A 化为上三角矩阵
        int pivot = k;              // 寻找主元（部分主元选择，避免数值不稳定）
        double max_val = abs(A[k][k]);
        for (int i = k + 1; i < n; i++) {
            if (abs(A[i][k]) > max_val) {
                max_val = abs(A[i][k]);
                pivot = i;
            }
        }
        if (pivot != k) {   // 交换行
            swap(A[k], A[pivot]);
            swap(b[k], b[pivot]);
        }
        // 检查主元是否接近零
        if (abs(A[k][k]) < 1e-9) return false;

        for (int i = k + 1; i < n; i++) {   // 消去
            double factor = A[i][k] / A[k][k];
            for (int j = k; j < n; j++) A[i][j] -= factor * A[k][j];
            b[i] -= factor * b[k];
        }
    }
    
    // 回代求解
    x.resize(n);
    for (int i = n - 1; i >= 0; --i) {
        double sum = 0.0;
        for (int j = i + 1; j < n; j++) sum += A[i][j] * x[j];
        x[i] = (b[i] - sum) / A[i][i];
    }
    return true;
}
```

#### 1.3 c++参考代码2
```c++
// Times of testing: 0
// 高斯消去法求解线性方程组 Ax = b，A 必须是方阵，b 大小与 A 行数一致
// 无解返回 -1，无穷多解返回 0，唯一解返回 1
int gaussian_elimination(vector<vector<double> > A, vector<double> b, vector<double>& x) {
    int n = A.size();
    int r = 0;  // 记录矩阵的秩

    // 前向消元
    for (int k = 0; k < n && r < n; k++) {
        // 部分主元选择：在当前列k中，从第r行开始寻找最大主元
        int pivot = r;
        double max_val = abs(A[r][k]);
        for (int i = r + 1; i < n; i++) {
            if (abs(A[i][k]) > max_val) {
                max_val = abs(A[i][k]);
                pivot = i;
            }
        }

        // 如果找到的主元太小，视为零，跳过该列
        if (abs(A[pivot][k]) < 1e-9) {
            continue;
        }

        // 交换行
        if (pivot != r) {
            swap(A[r], A[pivot]);
            swap(b[r], b[pivot]);
        }

        // 消元操作
        for (int i = r + 1; i < n; i++) {
            double factor = A[i][k] / A[r][k];
            for (int j = k; j < n; j++) {
                A[i][j] -= factor * A[r][j];
            }
            b[i] -= factor * b[r];
        }

        r++;  // 增加秩
    }

    // 检查无解：增广矩阵的秩 > 系数矩阵的秩
    for (int i = r; i < n; i++) {
        if (abs(b[i]) > 1e-9) {
            return -1;
        }
    }

    // 检查无穷多解：系数矩阵的秩 < 未知数个数
    if (r < n) {
        return 0;
    }

    // 唯一解：回代求解
    x.resize(n);
    for (int i = n - 1; i >= 0; i--) {
        double sum = 0.0;
        for (int j = i + 1; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        x[i] = (b[i] - sum) / A[i][i];
    }

    return 1;
}
```

### 2 矩阵求逆

#### 2.1 高斯-约当消元法求解逆矩阵（c++代码）

```c++
// 计算模意义下的逆矩阵
// Times of testing: 1
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

const ll mod = 1e9 + 7;

ll ksm(ll a, ll n) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

ll inv(ll a) {
    return ksm(a, mod - 2);
}

// 计算模意义下的逆矩阵，存在逆矩阵返回 true，不存在返回 false
bool inverse_matrix(vector<vector<ll> > &A, vector<vector<ll> > &res) {
    int n = A.size();
    for (int i = 0; i < n; i++) {
        A[i].resize(2 * n, 0);
        A[i][i + n] = 1;
    }
    // 向前消去
    for (int i = 0; i < n; i++) {
        int row = i;
        // 选主元
        for (int j = i + 1; j < n; j++) {
            if (A[j][i] > A[row][i]) {
                row = j;
            }
        }
        if (row != i) swap(A[i], A[row]);
        if (A[i][i] == 0) return false;     // 不存在逆矩阵
        for (int j = 0; j < n; j++) {
            if (j == i) continue;
            ll a = A[j][i] * inv(A[i][i]) % mod;
            for (int k = i; k < 2 * n; k++) {
                A[j][k] = ((A[j][k] - a * A[i][k]) % mod + mod) % mod;
            }
        }
        // 归一化
        ll a = inv(A[i][i]);
        for (int j = i; j < 2 * n; j++) A[i][j] = A[i][j] * a % mod;
    }

    res.resize(n, vector<ll>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            res[i][j] = A[i][j + n];
        }
    }
    return true;
}
```