### 拓展欧几里得算法

已知 $a$，$b$，拓展欧几里得可以求得 $gcd(a, b)$和 $ax + by = gcd(a, b)$的一组整数解 $x$ 与 $y$。

$$gcd(a, b) = gcd(b, a \bmod b)$$

如果现在存在 $x_2$，$y_2$ 使得

$$bx_2 + (a \bmod b)y_2 = gcd(b, a \bmod b)$$

那么会有

$$ax + by = bx_2 + (a \bmod b)y_2 $$ $$\Downarrow$$

$$ax + by = bx_2 + (a - b \times (a / b))y_2$$

$$\Downarrow$$

$$ax + by = bx_2 + ay_2 - b \times (a / b)y_2$$

$$\Downarrow$$

$$ ax + by = ay_2 + b(x_2 - (a / b)y_2)$$

此时得到一组解

$$\left\{\begin{aligned}x&=y_2\\y&=x_2 - (a / b)y_2\end{aligned}\right.$$

可以采取**递归**的方法，重复这个过程直至**普通欧几里得算法**的**递归基**即$$b = 0$$

此时易知使得$ax_n + by_n = gcd(a, b)$成立，即
$$\left\{\begin{aligned}x_n&=1\\y_n&=0\end{aligned}\right.$$

在回溯过程中可计算得到 $x$，$y$

#### c++代码实现

```c++
using ll = long long;
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { // 递归终止
        x = 1;
        y = 0;
        return a;
    }
    ll gcd = exgcd(b, a % b, x, y);
    ll tmp = x;
    x = y;  // x = y_2
    y = tmp - (a / b) * y;  // y = x_2 - (a / b) * y_2
    return gcd;
}
```