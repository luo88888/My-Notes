### 卢卡斯定理（Lucas）

给定 n，m，p，其中 p 是质数且不是很大，求

$$\binom{n}{m} \mod p$$

卢卡斯定理

$$
\binom{n}{m} = \binom{\lfloor \frac{n}{p} \rfloor} {\lfloor \frac{m}{p} \rfloor} \cdot \binom{n \mod p}{m \mod p} \pmod{p}
$$

#### 参考代码
```cpp
// Times of testing: 1
ll ksm(ll a, ll n, ll mod) {
    ll res = 1;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

ll inv(ll a, ll mod) {
    return ksm(a, mod - 2, mod);
}

// ll C(ll n, ll m, ll mod) {
//     if (m > n) return 0;
//     ll res = 1;
//     for (ll i = 1; i <= m; i++) {
//         res = res * (n - i + 1) % mod * inv(i, mod) % mod;
//     }
//     return res;
// }

// 优雅的组合数 C(n, m) mod p，要求 n, m < p，且 p 是质数
ll C(ll n, ll m, ll p) {
    if (m < 0 || m > n) return 0;
    if (m == 0 || m == n) return 1;

    // 利用对称性：C(n, m) = C(n, n-m)
    m = min(m, n - m);

    ll numerator = 1, denominator = 1;

    for (ll i = 0; i < m; i++) {
        numerator = numerator * (n - i) % p;      // (n)(n-1)...(n-m+1)
        denominator = denominator * (i + 1) % p;  // m!
    }

    return numerator * inv(denominator, p) % p;
}

ll Lucas(ll n, ll m, ll mod) {
    if (m == 0) return 1;
    if (n < mod && m < mod) return C(n, m, mod);
    return Lucas(n / mod, m / mod, mod) * C(n % mod, m % mod, mod) % mod;
}
```
